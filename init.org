# -*- eval: (add-hook 'after-save-hook (lambda ()(org-babel-tangle)) nil t); -*-

#+title: Emacs Configuration
#+author: Thomas Freeman
#+date: Time-stamp: <2022-04-25 23:02:17 thomas>
#+description: This org-mode file contains an org-babel implementation of the .emacs or .emacs.d/init.el file.
#+language: en
#+property: header-args :results silent :exports code
#+options: tex:t

#+options: html-link-use-abs-url:nil html-postamble:auto
#+options: html-preamble:t html-scripts:nil html-style:t
#+options: html5-fancy:nil tex:t
#+html_doctype: xhtml-strict
#+html_container: div
#+html_content_class: content
#+description:
#+keywords:
#+html_link_home: index.html
#+html_link_up: index.html
#+html_mathjax:
#+html_equation_reference_format: \eqref{%s}
#+html_head:
#+html_head_extra:
#+subtitle:
#+infojs_opt:
#+creator: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.1 (<a href="https://orgmode.org">Org</a> mode 9.5.2)
#+latex_header:

#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup


Welcome to my Emacs configuration! This file contains the code along with documentation for customizing my Emacs with all the options that I prefer to use by default.

This file was written using Emacs Org Mode. This makes navigating and modifying my Emacs configuration much simpler as I can place different elements of my configuration under separate headings. The code in this file is placed in source code blocks that are tangled to the ~init.el~ file that Emacs will look for upon starting. When this file is saved, the source code blocks that are marked for tangling will write their contents to ~init.el~.

* Header for ~init.el~

The following code block will add a header to the ~init.el~ file when it is generated on saving:

#+begin_src emacs-lisp :tangle yes
  ;; -*- lexical-binding: t -*-
  ;; 
  ;;; init.el --- Emacs initialization file

  ;; Author: Thomas Freeman
  ;; Maintainer: Thomas Freeman
  ;; Created: 09 Jan 2022

  ;; URL: https://github.com/tfree87/.emacs.d

  ;; This file is an init file for Emacs.
  ;; This file IS NOT intended to be edited! It was generated by init.org.

  ;; For documentation and for editing this file, see the init.org in the
  ;; github repository tfree87/.emacs.d
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#+end_src

* Performance Optimization Start

In order to slightly reduce the load time for Emacs, the whole ~init.el~ file can be wrapped in the following let statement to speed up the load process. This can help a little when Emacs is run as a portable app from a flash drive as I often do.See [[https://www.reddit.com/r/emacs/comments/3kqt6e/2_easy_little_known_steps_to_speed_up_emacs_start/][this Reddit post]] for more information.

#+begin_src emacs-lisp :tangle yes
  (let ((file-name-handler-alist nil))
#+end_src

* Running Emacs as a Portable App

I like to use Emacs at work and at home to boost my productivity, but I often find when I am at work or using another computer using Windows and I cannot always install Emacs to the host system. In this case, I run Emacs from a USB thumb drive so that I can still have access to the power of Emacs even when I am not working on my home personal computer. Running Emacs from a thumb drive has some caveats. For instance, if you are running Emacs from a thumb drive on a work computer and you do not have administrator access, then a lot of features will break. This section contains code that can be used to run Emacs.

** Check for Portable Emacs Instance

When runemacs.bat is executed, it will set the environment variable ~EMACS_PORTABLE~ to "Y". By checking for this, we can tell that Emacs that it was executed to be run from a flash drive.

#+name: portable_check
#+begin_src emacs-lisp
  (eq (getenv "EMACS_PORTABLE") "Y")
 #+end_src
 
** Set Location of Portable Git

Straight.el cannot operate without access to Git. Luckily, there is a portable version of Git ([[https://github.com/sheabunge/GitPortable][sheabunge/GitPortable]]) for Windows that can be installed on the [[https://portableapps.com/][PortableApp]] platform to provide access to Git without having it installed on the host system. After downloading GitPortable, we need to tell Emacs where it can find the binary executable so that Emacs programs can call Git when needed.

The following line code will check to see if Emacs is being run as a portable app and, if it is, then add the path where git.exe can be found to the ~exec-path~ list:

 #+begin_src emacs-lisp :tangle yes :noweb yes
   (when <<portable_check>>
     (add-to-list 'exec-path "~/PortableApps/GitPortable/App/Git/bin"))
 #+end_src

* Custom Set Variables

In order to keep variables set by the customize interface or set during Emacs at runtime from being placed at the top of ~init.el~, I set the variables set from Emacs customize to be put into a separate file [[./custom.el]].

#+name: custom-file
#+begin_src emacs-lisp :tangle yes

  ;; Set the location of variables set using Emacs customize interface

  (setq custom-file "~/.emacs.d/custom.el")
#+end_src

Once the file location has been set, Emacs needs to load the custom file. This needs to be done early in the loading process because it contains the addresses for the package repositories. If this is not loaded before refreshing packages and making calls to ~use-package~, then the ~:ensure~ command will not be able to pull the packages and install them.

#+name: load-custom
#+begin_src emacs-lisp :tangle yes

  ;; Load the file custom.el file containing variables from Emacs customize

  (load custom-file)
#+end_src

* Package Management

In this section, I have included customization to replace the default Emacs package manager with [[https://github.com/raxod502/straight.el][straight.el]]. Some reasons for making this switch are:

1. It is easier to avoid conflicts with different package repositories such as duplicates packages in ELPA and MELPA.
2. I can define a specific fork to use for a specific package to get bug fixes or modifications.
3. The entire package repository is cloned, which, while it takes up a lot of space, allows for editing the source code directly if desired.
4. Github repositories that are not included in ELPA, MELPA, or marmalade can be pulled 
 used in ~use-package~ statements.
 
** Straight.el

Instead of using the built-in package manager, use [[https://github.com/raxod502/straight.el][straight.el]] to pull all the packages straight from their repositories.

#+begin_src emacs-lisp :tangle yes

  ;; Install Straight.el to manage packages

  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name
          "straight/repos/straight.el/bootstrap.el"
          user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
 #+end_src
 
** Install use-package

Use ~straight.el~ to install ~use-package~ to manage Emacs packages.

#+begin_src emacs-lisp :tangle yes
  ;; Set up use-package to manage package loading

  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)
#+end_src

* Startup Tools

This section contains many of the tools used at Emacs startup that are helpful when other packages are initialized.

#+begin_src emacs-lisp :tangle yes
;; Emacs Startup Tools
#+end_src

** Benchmark Init

The [[https://github.com/dholm/benchmark-init-el][benchmark init]] package allows me to track how long each component of my Emacs init takes to load. Normally, a long load time for Emacs would not bother me, however, as I use this same configuration for the portable version of Emacs that I run from a flash drive, decreasing the init time is critical as the thumb drive runs extremely slow in comparison to the native desktop application.

#+begin_src emacs-lisp :tangle yes
  (use-package benchmark-init
    :straight t
    :config
    (benchmark-init/activate)
    (add-hook 'after-init-hook #'benchmark-init/deactivate))
#+end_src

** Blackout :disabled:

[[https://github.com/raxod502/blackout][Blackout]] provides a means to hide mode names from the mode line. After a lot of customization of Emacs, the mode line can get very crowded with minor modes that are always on and it is not necessary to be reminded that they are active. Also, too many minor modes hides my nyan cat :(.

#+begin_src emacs-lisp :tangle yes
  (use-package blackout
    :disabled t
    :straight t)
#+end_src

** No-littering

The [[https://github.com/emacscollective/no-littering][no-littering]] package will put Emacs configuration files for many third-party packages into separate folders under ~.emacs.d/etc/~ to help keep the ~.emacs.d/~ from getting to cluttered with different configuration files. This needs to be run before the other packages are initialized in order to ensure that when the pacakges are loaded that their configuration files will be put into the correct location.

#+begin_src emacs-lisp :tangle yes
  (use-package no-littering
    :straight (no-littering :host github
                            :repo "emacscollective/no-littering"
                            :branch "master"))
#+end_src

** Whicher

[[https://github.com/abo-abo/whicher][Whicher]] provides a quick tool to check for missing executable dependencies without much cost to Emacs startup time. This needs to be loaded before the rest of init.el so that as init.el is loaded, it can look for missing executables on the host system.

#+begin_src emacs-lisp :tangle yes
  (use-package whicher
    :straight (whicher :host github
                       :repo "tfree87/whicher"
                       :branch "master")
    :custom
    (whicher-report-new-buffer t))
#+end_src

* Emacs Options

The code below collects customizations for Emacs built-in components.

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package emacs
    :custom
    <<emacs_custom>>
    :config
    <<emacs_config>>)
#+end_src

** General Configuration

This section contains modifications for Emacs that affect the behavior in nearly all buffers.

*** Automatic Time Stamps

Emacs supports time stamps in any text buffer where ~Time-stamp: <>~ can be found in the first eight lines. The ~time-stamp~ command can then be used to automatically update the time. A simpler solution, however, is to have Emacs automatically update the time stamp when the buffer is saved.

#+begin_src emacs-lisp :noweb-ref emacs_config
  (add-hook 'before-save-hook 'time-stamp)  
#+end_src

*** Desktop Save Mode

The following option will cause Emacs to always save the state of Emacs when it was closed. Local buffers, tabs in ~tab-bar-mode~, and window arrangements are all saved if possible. Turning this on makes it much simpler to continue working on the same projects when Emacs is closed and then opened again.

#+begin_src emacs-lisp :noweb-ref emacs_custom
(desktop-save-mode t)
#+end_src

*** File Deletion and Backup

Changing how Emacs deletes files and how it creates backups.

**** Send Deleted Files to System Trash

 Emacs does not send files to the trash by default which is counter-intuitive for many beginning users. /In order to risk losing files it is a good idea to turn on the option to send all files to the system trash./

 #+begin_src emacs-lisp :noweb-ref emacs_custom
   (delete-by-moving-to-trash t)
 #+end_src
 
**** Backup Files with Version Control

 Emacs has a built-in version control system in which it will create a series of backup files. This will create a number of backup flies, however, that will need to be cleaned up on a regular basis.


 #+begin_src emacs-lisp :noweb-ref emacs_custom
   (version-control t)
   (delete-old-versions t)
   (vc-make-backup-files t)
 #+end_src
 
*** Inhibit Startup Screen

After seeing the startup screen hundreds of times, there is no longer any need to load it on startup as it no longer contains any new information.

#+begin_src emacs-lisp :noweb-ref emacs_custom
  (inhibit-startup-screen t)
#+end_src

*** Register Delay

#+begin_src emacs-lisp :noweb-ref emacs_custom
  (register-preview-delay 0)
#+end_src

*** Shorten "Yes or No" to "Y or N"

To make work faster, instead of typing "yes" or "no" for each question prompt, use just "y" or "n"
.

#+begin_src emacs-lisp :noweb-ref emacs_config
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

* Auto-completion



** Cape

 [[https://github.com/minad/cape][Cape]] (completion at point extensions) provides some extensions to make autocompletion better and plays well with Corfu.
 
#+name: cape
#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package cape
    :straight t
    :bind (("C-c p p" . completion-at-point)
           ("C-c p t" . complete-tag)
           ("C-c p d" . cape-dabbrev)
           ("C-c p f" . cape-file)
           ("C-c p k" . cape-keyword)
           ("C-c p s" . cape-symbol)
           ("C-c p a" . cape-abbrev)
           ("C-c p \\" . cape-tex)
           ("C-c p _" . cape-tex)
           ("C-c p ^" . cape-tex))
    :init
    <<capfs>>)
#+end_src

*** Cape Completion Functions

Cape provides a number of ~completion-at-point~ functions that can be used. Below are the functions that I use that have not been intrusive.

The following will complete file names in buffers:

#+begin_src emacs-lisp :noweb-ref capfs
  (add-to-list 'completion-at-point-functions #'cape-file)
#+end_src

This will complete items in TeX and LaTeX modes:

#+begin_src emacs-lisp :noweb-ref capfs
  (add-to-list 'completion-at-point-functions #'cape-tex)
#+end_src

Search other buffers for completion candidates:

#+begin_src emacs-lisp :noweb-ref capfs
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
#+end_src

Complete keywords in programming modes:

#+begin_src emacs-lisp :noweb-ref capfs
  (add-to-list 'completion-at-point-functions #'cape-keyword)
#+end_src

Complete Emacs-lisp symbols:

#+begin_src emacs-lisp :noweb-ref capfs
  (add-to-list 'completion-at-point-functions #'cape-symbol)
#+end_src

** Consult

[[https://github.com/minad/consult][Consult]] provides a number of highly useful commands. The complete list of commands can be found [[https://github.com/minad/consult#available-commands][here]].

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package consult
    :straight t
    :bind (("C-c h" . consult-history)
           ("C-c m" . consult-mode-command)
           ("C-c k" . consult-kmacro)
           ("C-x M-:" . consult-complex-command)
           ("C-x b" . consult-buffer)
           ("C-x 4 b" . consult-buffer-other-window)
           ("C-x 5 b" . consult-buffer-other-frame)
           ("C-x r b" . consult-bookmark)
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)
           ("C-M-#" . consult-register)
           ("M-y" . consult-yank-pop)
           ("<help> a" . consult-apropos)
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)
           ("M-g g" . consult-goto-line)
           ("M-g M-g" . consult-goto-line)
           ("M-g o" . consult-outline)
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ("M-s d" . consult-find)
           ("M-s D" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s m" . consult-multi-occur)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)
           ("M-s e" . consult-isearch-history)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi))
    :config
    <<consult_config>>)
#+end_src

*** Use Consult to Select xref Locations

Use Consult to search through and select xref locations in buffers

#+begin_src emacs-lisp :noweb-ref emacs_custom
  (xref-show-xrefs-function #'consult-xref)
  (xref-show-definitions-function #'consult-xref)
#+end_src

*** Enhanced ~completing-read~ Function

Replace the default Emacs ~completing-read~ function with the enhanced ~consult-completing-read-multiple~.

#+begin_src emacs-lisp :noweb-ref emacs_config
  (advice-add #'completing-read-multiple
              :override #'consult-completing-read-multiple)
#+end_src

*** Change Register Preview to Consult

Change the default Emacs ~register-preview-function~ to use consult effectively.

#+begin_src emacs-lisp :noweb-ref emacs_custom
  (register-preview-function #'consult-register-format)
#+end_src

*** Tweak Register Preview Window

The following line makes the register preview window look better by adding sorting and thin lines to break up the results into easy to view categories.

#+begin_src emacs-lisp :noweb-ref emacs_config
  (advice-add #'register-preview
              :override #'consult-register-window)
#+end_src

*** Set the Narrowing Key

The narrowing key is pressed before a key used to narrow the results returned from consult. An example would be ~< m~ to list bookmarks after calling ~consult-buffer~.

#+begin_src emacs-lisp :noweb-ref consult_config
  (setq consult-narrow-key "<")
#+end_src

*** Set Root Function for Projects

Use the built-in project function to find the root of any project. Projectile can also be used but I have yet to compare the differences between the two projects to make a decision as to which one to use.

#+begin_src emacs-lisp :noweb-ref consult_config
  (setq consult-project-root-function
        (lambda ()
          (when-let (project (project-current))
            (car (project-roots project)))))
#+end_src

** Completion Cycling

Cycle through completion candidates by pressing the completion key.

#+begin_src emacs-lisp :noweb-ref emacs_custom
  (completion-cycle-threshold t)
#+end_src

** Completion by Pressing Tab

~<TAB>~ will indent lines by default. In order to turn ~<TAB>~ into a button that activates autocomplete, the ~tab-always-indent~ variable must be set to ~complete~. This will cause pressing ~<TAB>~ once to indent, and twice will cause it to activate autocomplete.

#+begin_src emacs-lisp :noweb-ref emacs_custom
  (tab-always-indent 'complete)
#+end_src

** Corfu

[[https://github.com/minad/corfu][Corfu]] for in-buffer completion. Corfu will provide an in-buffer popup window that will be populated with various completion options.

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package corfu
    :straight t
    :hook
    <<corfu_hooks>>
    :bind
    <<corfu_bind>>
    :custom
    (corfu-auto t)
    (corfu-cycle t)
    (corfu-preselect-first nil)
    <<tab-selection>>
    :init
    (corfu-global-mode)
    :config
    <<corfu_config>>)
#+end_src

*** Use TAB for Selecting Candidates

Instead of using M-tab which will switch windows in XFCE---my default desktop environment---use TAB to cycle between the different possible options.

#+name: tab-selection
#+begin_src emacs-lisp :noweb-ref corfu_bind
  (:map corfu-map
        ("TAB" . corfu-next)
        ([tab] . corfu-next)
        ("S-TAB" . corfu-previous)
        ([backtab] . corfu-previous))
#+end_src

*** Use Corfu in Eshell

Use Corfu to complete commands in Eshell

#+begin_src emacs-lisp :noweb-ref corfu_hooks
  (eshell-mode-hook . (lambda ()
                        (setq-local corfu-quit-at-boundary t
                                    corfu-quit-no-match t
                                    corfu-auto nil)
                        (corfu-mode)))
#+end_src
#+begin_src emacs-lisp :noweb-ref corfu_config
  ;; Silence the pcomplete capf, no errors or messages!
  (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-silent)

  ;; Ensure that pcomplete does not write to the buffer
  ;; and behaves as a pure `completion-at-point-function'.
  (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-purify)
#+end_src

*** Corfu-doc

Corfu-doc will bring up documentation results in a separate pop-up next to the corfu pop-up with the documentation of any function or variable results that are selected.

#+begin_src emacs-lisp :tangle yes
  (use-package corfu-doc
    :straight (corfu-doc :host github
                         :repo "galeo/corfu-doc"
                         :branch "main")
    :hook
    (corfu-mode . corfu-doc-mode)
    :config
    (define-key corfu-map (kbd "M-p") #'corfu-doc-scroll-down)
    (define-key corfu-map (kbd "M-n") #'corfu-doc-scroll-up))
#+end_src

** Embark :minibuffer:

[[https://github.com/oantolin/embark][Embark]] provides the ability to execute commands on completion options found in the minibuffer.

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package embark
    :straight t
    :bind
    (("C-." . embark-act)
     ("C-;" . embark-dwim)
     ("C-h B" . embark-bindings))
    :init
    (setq prefix-help-command #'embark-prefix-help-command)
    :config
    <<embark_config>>
    (define-key embark-file-map (kbd "S") 'sudo-find-file))
#+end_src

*** Embark Mode Line

Hide the mode line of the Embark live/completions buffers.

#+begin_src emacs-lisp :noweb-ref embark_config
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none))))
#+end_src

*** Embark Integration with Consult

Allow use of Embark commands after issuing a Consult command.

#+begin_src emacs-lisp :tangle yes
  (use-package embark-consult
    :straight t
    :after (embark consult)
    :demand t
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

** Orderless :minibuffer:

[[https://github.com/oantolin/orderless][Orderless]] will allow for seaching in the minibuffer using text broken up by spaces in which the order does not matter. For instance, if ~M-x~ is entered the search results will be the same if searching for a function by using the search key ~find file~ or ~file find~. Both entries will return the function ~find-file~ as the top result.

#+begin_src emacs-lisp :tangle yes
  (use-package orderless
    :straight t
    :defer 3
    :custom
    (completion-styles '(orderless))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Marginalia :minibuffer:

[[https://github.com/minad/marginalia][Marginalia]] generates annotations to items in the minibuffer similar to what is accomplished  with [[https://github.com/Yevgnen/ivy-rich][ivy-rich]].

#+begin_src emacs-lisp :tangle yes
  (use-package marginalia
    :straight t
    :bind (("M-A" . marginalia-cycle)
           :map minibuffer-local-map
           ("M-A" . marginalia-cycle))
    :init
    (marginalia-mode))
#+end_src

** Vertico :minibuffer:

[[https://github.com/minad/vertico][Vertico]] removes the ~*Completions*~ buffer and instead, populates a vertical list of completion options in the minibuffer region. This is similar to other completion tools in Emacs such Helm, Ivy, Selectrum, and icomplete-vertical.

#+begin_src emacs-lisp :tangle yes
  (use-package vertico
    :straight t
    :demand t
    :custom
    (vertico-cycle t)
    (vertico-resize t)
    :init
    (vertico-mode))
#+end_src

* Coding

The following customizations are used to improve the coding environment in Emacs.

** Aggressive Indent

[[https://github.com/Malabarba/aggressive-indent-mode][Aggressive indent mode]] will keep code indented by the correct amount as you type in real time. This saves having to go back and reformat all the tabbing in code after making changes.

#+begin_src emacs-lisp :tangle yes
  (use-package aggressive-indent
    :straight t
    :hook
    (c-mode . aggressive-indent-mode)
    (emacs-lisp-mode . aggressive-indent-mode)
    (go-mode . aggressive-indent-mode))
#+end_src

** Apheleia :python:go:

[[https://github.com/raxod502/apheleia][Apheleia]] will format programming code using code formatters such as Black for Python. The main difference between using Apheleia over formatters like Black is that Apheleia will format the code asynchronously in the background without disturbing your cursor position in the buffer making a more streamlined experience that is more pleasant for editing and saving repeatedly as I often do.

#+begin_src emacs-lisp :tangle yes
  (use-package apheleia
    :straight t
    :hook
    (prog-mode . apheleia-mode)
    (tex-mode . apheleia-mode)
    :config
    (setf (alist-get 'black apheleia-formatters)
    '("black" "--experimental-string-processing" "-")))
#+end_src

** C

I have added ~.ino~ files to C mode so that I can have syntax highlighting when I program my Arduino board.

#+begin_src emacs-lisp :tangle yes
  (use-package c-mode
    :straight (:type built-in)
    :defer t
    :mode ("\\.c\\'"
           "\\.ino\\'"))
#+end_src

** Elpy :python:disabled:

[[https://github.com/jorgenschaefer/elpy][Elpy]] adds powerful features for Python progamming in Emacs.

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package elpy
    :straight t
    :defer t
    :init
    (advice-add 'python-mode :before 'elpy-enable)
    :custom
    (elpy-rpc-python-command (whicher "python3"))
    (python-shell-interpreter (whicher "ipython3"))
    (python-shell-interpreter-args "-i --simple-prompt")
    :config
    <<elpy_config>>) 
#+end_src

*** Use Flycheck for Python Syntax

Check python syntax while writing with flycheck

#+begin_src emacs-lisp :noweb-ref elpy_config
  (when (load "flycheck" t t)
    (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
    (add-hook 'elpy-mode-hook 'flycheck-mode))
#+end_src

** Flycheck :python:

[[https://www.flycheck.org/en/latest/][Flycheck]] can check programming syntax while typing.

#+begin_src emacs-lisp :tangle yes
  (use-package flycheck
    :straight t
    :defer t)
#+end_src

** Go

[[https://github.com/dominikh/go-mode.el][Go mode]] provides a major model for editing Go code.

#+begin_src emacs-lisp :tangle yes
  (use-package go-mode
    :straight t
    :defer t)
#+end_src

** Indent Using Spaces :python:

Indenting with spaces rather than tabs is genrally recommended when working with code. Especially when writing code in Python.

#+begin_src emacs-lisp :noweb-ref emacs_config
(setq-default indent-tabs-mode nil)
#+end_src

** LSP Mode :testing:

I am considering replacing elpy with LSP Mode. I will try this out for now but at the moment is seems slow.

#+begin_src emacs-lisp :tangle yes
(use-package lsp-mode
  :hook
  ((python-mode . lsp)))

(use-package lsp-ui
  :commands lsp-ui-mode)
#+end_src

** Minimap

[[https://github.com/dengste/minimap][Minimap]] shows a smaller window next to the main window where an overview of the whole buffer is presented and displays where the active region relates to the overall structure.

#+begin_src emacs-lisp :tangle yes
  (use-package minimap
    :straight t
    :defer t)
#+end_src

** Magit

[[https://magit.vc/][Magit]] provides an interface to Git through Emacs. It is very helpful to be able to command Git with Magit as it requires much less context switching since I do not need to save code and then switch to a terminal to run Git commands.

#+begin_src emacs-lisp :tangle yes
  (use-package magit
    :init
    (whicher "git")
    :straight t
    :bind ("C-x g" . magit-status))
#+end_src

** Number Line Mode

Number lines can be very useful in programming modes. This code below will turn on the built-in ~display-line-numbers-mode~ in any major mode that inherits from ~prog-mode~. With wide monitors these days it is less of an issue and it can always toggled off with  ~display-line-numbers-mode~ on the fly.

#+begin_src emacs-lisp :noweb-ref emacs_config
    (when (version<= "26.0.50" emacs-version)
      (add-hook 'prog-mode-hook 'display-line-numbers-mode))
#+end_src

** Numpydoc :python:

Using [[https://github.com/douglasdavis/numpydoc.el][Numpydoc]] provides an interactive tool to automatically generate Numpy style docstrings.

#+begin_src emacs-lisp :tangle yes
  (use-package numpydoc
    :straight t
    :bind (:map python-mode-map
                ("C-c C-n" . numpydoc-generate)))
#+end_src

** Paren Mode

Paren Mode will highlight matching parentheses in programming mode buffers making it easy to determine if delimiters have been matched and what nested-level code is being written in.

The following code will always highlight matching parenthesis when coding /immediately/ without delay. A hook was added to defer loading the package until a programming mode:

#+begin_src emacs-lisp :tangle yes  
  (use-package paren
    :defer t
    :custom
    (show-paren-delay 0)
    :hook (prog-mode . show-paren-mode))
#+end_src

** Rainbow Delimiters

[[https://github.com/Fanael/rainbow-delimiters][Rainbow delimiters]] colors delimiters such as brackets and parentheses in source code making it easier to identify which delimiters are paired up. This can be a quick and easy way to check to see if all open delimiters are closed off without having to rely entirely on ~paren-mode~ and ~backward-sexp~.

#+begin_src emacs-lisp :tangle yes
  (use-package rainbow-delimiters
    :straight t
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

** Show Column Number

Many style guides to programming languages recommend that each line of code is less than 80 characters long. To determine if code lines are too long, a simple tool is to activate ~column-number-mode~. Once enabled, the current column (i.e. the number of characters on that line) will be displayed.

#+begin_src emacs-lisp :noweb-ref emacs_custom
  (column-number-mode t)
#+end_src

A better fix would be to use code formatters to prevent lines from getting too long. For example, [[Apheleia]] will run formatters such as Black on Python code to keep code lines from becoming too long.

** Treemacs

[[https://github.com/Alexander-Miller/treemacs][Treemacs]] provides a separate Emacs window to browse file directory trees for projects.

#+begin_src emacs-lisp :tangle yes
  (use-package treemacs
    :straight t
    :defer t
    :init
    (whicher "git")
    (with-eval-after-load 'winum
      (define-key winum-keymap (kbd "M-0") #'treemacs-select-window))
    :custom
    (treemacs-show-hidden-files t)
    (treemacs-wide-toggle-width 60)
    (treemacs-width 30)
    (treemacs-width-is-initially-locked nil)
    (treemacs-follow-mode t)
    (treemacs-filewatch-mode t)
    (treemacs-fringe-indicator-mode 'always)
    (treemacs-hide-gitignored-files-mode nil)
    :config
    (treemacs-load-theme "all-the-icons")
    (pcase (cons (not (null (executable-find "git")))
                 (not (null treemacs-python-executable)))
      (`(t . t)
       (treemacs-git-mode 'deferred))
      (`(t . _)
       (treemacs-git-mode 'simple)))
    :bind
    (:map global-map
          ("M-0"       . treemacs-select-window)
          ("C-x t 1"   . treemacs-delete-other-windows)
          ("C-x t t"   . treemacs)
          ("C-x t d"   . treemacs-select-directory)
          ("C-x t B"   . treemacs-bookmark)
          ("C-x t C-t" . treemacs-find-file)
          ("C-x t M-t" . treemacs-find-tag)))

  (use-package treemacs-projectile
    :after (treemacs projectile)
    :straight t)

  (use-package treemacs-all-the-icons
    :after treemacs
    :straight t
    :config (treemacs-load-theme 'all-the-icons))

  (use-package treemacs-magit
    :after (treemacs magit)
    :straight t)
#+end_src

* File Browsing

** Dired

The following customizations make emacs dired mode behave in a similar fashion to other file browsing tools such as midnight commander. While there are many great file management tools out there. I keep coming back to emacs dired because of the keyboard commands and flexibility.

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package dired
    :straight nil
    :ensure nil
    :defer t
    :custom
    <<dired_custom>>)
#+end_src

*** Move/Rename/Copy Files to Another Pane

This will cause emacs to default to moving/copying/renaming files from the directory in one dired buffer to another in a split-window. This will allow emacs to operate more like midnight commander, total commander, double commander, etc.

 #+begin_src emacs-lisp :noweb-ref dired_custom
   (dired-dwim-target t)
 #+end_src
 
** Disc Usage

Disc usage is a tool that can be used to determine the amount of memory a directory uses in the file system.

#+begin_src emacs-lisp :tangle yes
  (use-package disk-usage
    :straight t
    :defer t)
#+end_src

** Sunrise Commander

[[https://github.com/sunrise-commander/sunrise-commander][Sunrise Commander]] is a two-pane orthodox file manager similar to Midnight Commander.

#+begin_src emacs-lisp :tangle yes
  (use-package sunrise-commander
    :defer t
    :straight t)
#+end_src

** Tramp

I occasinally use [[https://www.gnu.org/software/tramp/][Tramp]] to access remote files but it seems to have problems when the default shell is set to zsh. Setting it so bash has fixed this issue for me.

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package tramp
    :straight <<tramp_version>>
    :defer t
    :config
    (with-eval-after-load 'tramp
      (setenv "SHELL" "/bin/bash")))
#+end_src

*** TRAMP Version

The latest version of TRAMP throws an error when using sunrise-commander, using the built-in version of tramp fixes this.

#+begin_src emacs-lisp :noweb-ref tramp_version
  (:type built-in)
#+end_src

* Navigation

** Ace Window :disabled:

[[https://github.com/abo-abo/ace-window][ace-window]] makes it really easy to switch between different windows in Emacs. A red number will appear in the upper left-hand corner of each window after calling ~ace-window~ and selecting that number will make that window the current active buffer.

#+begin_src emacs-lisp :tangle yes
  (use-package ace-window
    :straight t
    :disabled t
    :bind ("s-o" . ace-window))
#+end_src

** Winner Mode

Winner Mode makes it easy to return to old window configurations in Emacs by simply using the keyboard command ~C-<left>~.

#+begin_src emacs-lisp :noweb-ref emacs_config
  (winner-mode t)
#+end_src

** Winum

Winum is a package that adds number to the modeline for each window in Emacs. Windows can then easily be switched from one to the next by using the key combination ~C-x w~ followed by the number of the correct window.

This package is similar to [[https://github.com/abo-abo/ace-window][ace-window]] but it has a few advantages:

1. This package has a key binding that does not conflict with ~M-o~ in [[Sunrise Commander]]
2. This package works well with EXWM. Ace Window numbers do not display in EXWM windows that are running X11 applications.
3. ~C-x w~ is similar to the window creation and deletion commands ~C-x~ which may make it easier to remember the key binding.


#+begin_src emacs-lisp :tangle yes
  (use-package winum
    :straight t
    :defer 3
    :config
    (winum-mode t))
#+end_src

* Organization/Time Management/Notes

Emacs is a great tool for managing projects, organizing information, calendaring, and note taking. A number of tools and extensions to Emacs make it great for this purpose.

** Calfw

[[https://github.com/kiwanami/emacs-calfw][Calfw]] provides a grid-based calendar view similar to what is seen in most graphical calendar programs but integrates the org agenda files. I use the fork from @zemaye as this version has fixed the issue in ~calfw-org.el~ where events that span multiple dates show up repeated on the display.

#+begin_src emacs-lisp :tangle yes
  (use-package calfw
    :straight (emacs-calfw :host github
                           :repo "zemaye/emacs-calfw"
                           :branch "master")
    :commands (cfw:open-calendar-buffer)
    :init
    (defalias 'calfw 'cfw:open-calendar-buffer)
    :custom
    (cfw:fchar-junction ?╋)
    (cfw:fchar-vertical-line ?┃)
    (cfw:fchar-horizontal-line ?━)
    (cfw:fchar-left-junction ?┣)
    (cfw:fchar-right-junction ?┫)
    (cfw:fchar-top-junction ?┯)
    (cfw:fchar-top-left-corner ?┏)
    (cfw:fchar-top-right-corner ?┓))
#+end_src

*** ~calfw-org~ :org:

~calfw-org.el~  displays org-mode events in the ~calfw~ calendar. I don't like the long command ~M-x cfw:open-org-calendar~ so I have shortened to it to ~M-x calfworg~ which is much easier to type and remember.

#+begin_src emacs-lisp :tangle yes
  (use-package calfw-org
    :straight (emacs-calfw :host github
                           :repo "zemaye/emacs-calfw"
                           :branch "master")
    :commands (cfw:open-org-calendar)
    :init
    (defalias 'calfworg 'cfw:open-org-calendar))
#+end_src

** Deft :org:

[[https://github.com/jrblevin/deft][Deft]] is an Emacs package that makes it easier to make quick notes that can be easily searched later. Deft allows for searching the full text of notes and the search results get narrowed down as you

#+begin_src emacs-lisp :tangle yes
  (use-package deft
    :after org
    :defer t
    :bind
    ("C-c n d" . deft)
    :commands (deft)
    :custom
    (deft-recursive t)
    (deft-use-filter-string-for-filename t)
    (deft-default-extension "org")
    (deft-directory "~/Dropbox/org-roam/")
    (deft-strip-summary-regexp ":PROPERTIES:\n\\(.+\n\\)+:END:\n")
    (deft-use-filename-as-title t))
#+end_src

** Habitica :org:

#+begin_src emacs-lisp :tangle yes
  (use-package habitica
    :after org
    :custom
    (habitica-turn-on-highlighting t)
    (habitica-show-streak t))
#+end_src

** Org :org:

[[https://orgmode.org/][Org Mode]] is the powerful task management, calendar, agenda, publishing system, and code documentation tool all-in-one that really extends the power of Emacs. I use Org Mode for the following:

- Organizing my tasks and projects similar to David Allen's "Getting Things Done" method
- Publishing LaTeX documents in a simpler and faster way
- Saving reusable code snippets with documentation that can be executed from within Emacs as how this file was created.
  
#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package org
    :defer t
    :init
    (whicher "pdflatex")
    (whicher "biber")
    :bind
    ("C-c l" . #'org-store-link)
    ("C-c a" . #'org-agenda)
    ("C-c c" . #'org-capture)
    :custom
    <<org_customize>>
    :config
    (add-hook 'org-mode-hook #'turn-on-flyspell)
    <<org_config>>
    <<babel_languages>>
    (fm/org-header-formatting))

  (use-package org-contrib
    :straight t
    :defer t
    :config
    <<org_contrib_config>>)
#+end_src

*** Directories

Set up the default directories for Org Mode.

**** Default Directory

Tell org-mode which directory is the default directory for all org-mode files.

#+begin_src emacs-lisp :noweb-ref org_customize
  (org-directory "~/Dropbox/gtd")
#+end_src

**** Location of Agenda Files

Tell org-mode in which directory all the agenda files can be found.

#+begin_src emacs-lisp :noweb-ref org_customize
  (org-agenda-start-on-weekday nil)
  (org-agenda-files `("~/Dropbox/gtd"))
#+end_src

*** Filing Notes

**** Default Notes File

I prefer to have all of my captured notes automatically filed into a file called ~inbox.org~. Changing ~org-default-notes-file~ can create this functionality.

#+begin_src emacs-lisp :noweb-ref org_customize
  (org-default-notes-file (concat org-directory "/inbox.org"))
#+end_src

**** Refile Targets

***** Set Org Files for Refiling

In order to refile/move tasks from the inbox to other agenda files and subtrees, the following must be set:

#+begin_src emacs-lisp :noweb-ref org_customize
  (org-refile-targets '((org-agenda-files :maxlevel . 3)))
#+end_src

***** Allow Refile as Top-level Heading

I want to allow for refiling org-mode tasks at the top of a file. Setting this will also require turning off completing the path in steps if ivy-mode autocompletion is used.

#+begin_src emacs-lisp :noweb-ref org_customize
  (org-refile-use-outline-path 'file)
  (org-outline-path-complete-in-steps nil)
#+end_src
 
Setting this variable allows for refiling tasks under a new heading on the fly.

#+begin_src emacs-lisp :noweb-ref org_customize
  (org-refile-allow-creating-parent-nodes (quote confirm))
#+end_src

*** Exporting

To remove headers labeled with the ~:ignore:~ tag, the following code needs to be implemented:

#+begin_src emacs-lisp :noweb-ref org_contrib_config
  (require 'ox-extra)
  (ox-extras-activate '(ignore-headlines))
#+end_src

*** Task Management Customization

**** Drawer for State Changes

Put changes of TODO states for org-mode into a drawer under each heading so that it does not conflict with content under the headings.

#+begin_src emacs-lisp :noweb-ref org_customize
  (org-log-into-drawer t)
#+end_src

**** Custom TODO Keywords

Set up the sequence of org-todo task keywords to allow for delegated (WAITING) tasks and CANCELED tasks.

#+begin_src emacs-lisp :noweb-ref org_customize
  (org-todo-keywords
   '((sequence "TODO(t)"
               "WAITING(w)"
               "|" "DONE(d)"
               "CANCELED(c)")))
#+end_src

**** Project Tags

I like to mark projects with a tag, however, I do not want my tasks to inherit these tags because I only use the project tags to locate upper-level headings. In addition, almost all of my org-mode tasks fall under some sort of project headline so it becomes meaningless if all of my tasks have the project tag. Changing this setting prevents the tag from being inherited and showing up in the agenda view.

#+begin_src emacs-lisp :noweb-ref org_customize
  (org-tags-exclude-from-inheritance '("project"))
#+end_src

**** Stuck Projects

Stuck projects are projects which are going nowhere and need to be analyzed for next steps. Org-mode allows for custom definitions of what a "stuck project" can be so I define a stuck project as any headline with the project keyword which has no TODO item below it. Org-mode by default assumes all level 2 headings are projects which is not the case in my setup.

#+begin_src emacs-lisp :noweb-ref org_customize
  (org-stuck-projects
   '("+project/-MAYBE-DONE"
     ("NEXT" "TODO")
     nil
     "\\<IGNORE\\>"))
#+end_src

*** BibLaTeX in Org-mode

I prefer BibLaTeX over the standard BibTeX as it has more powerful features and supports more citation styles. In order to get BibLaTeX to operate in org-mode, the ~org-latex-pdf-process~ variable needs to be changed to reflect this.

#+begin_src emacs-lisp :noweb-ref org_customize
  (org-latex-pdf-process
   '("pdflatex -interaction nonstopmode -output-directory %o %f"
     "biber %b"
     "pdflatex -interaction nonstopmode -output-directory %o %f"
     "pdflatex -interaction nonstopmode -output-directory %o %f"))
#+end_src

*** Org-babel Languages

In order to use active code in org-mode, you must define which programming languages to load. For any programming language you wish to use, it must be added to the ~org-babel-load-languages~ list.

#+name: babel_languages
#+begin_src emacs-lisp
  (with-eval-after-load "org"
    (add-to-list 'org-src-lang-modes '("plantuml" . plantuml)))
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((awk . t)
     (calc . t)
     (css . t)
     (emacs-lisp . t)
     (eshell . t)
     (gnuplot . t)
     (dot . t)
     (latex . t)
     (ledger . t)
     (octave . t)
     (plantuml . t)
     (R . t)
     (sed . t)
     (shell . t)))
#+end_src

*** Appearance

This section contains modifications to how Org Mode appears in buffers.

**** Hide Emphasis Characters

Hiding emphasis characters  in Org Mode makes the text easier to read when it is being displayed directly in Emacs. This will make *bold*, /italic/, _underlined_, ~code~, and =verbatim= text show up without the ~*~, /, _, ~, and = characters around them. 

#+begin_src emacs-lisp :noweb-ref org_customize
  (org-hide-emphasis-markers t)
#+end_src

**** Word Wrapping

Turning on ~visual-line-mode~ allows the text to flow in Org Mode as if working in a word processors.

#+begin_src emacs-lisp :noweb-ref org_config
  (add-hook 'org-mode-hook 'visual-line-mode)
#+end_src

**** Single Space Between Headline and Tags

I keep only a single space between the headline because I find it easier to owork with when buffer sizes change or if I am editing with a mobile device. It just seems to make things simpler.

#+begin_src emacs-lisp :noweb-ref org_customize
  (org-tags-column 0)
#+end_src

**** Use "Clean View"

Start all Emacs org-mode buffers with "clean-view" turned on. This makes it easier to see and read org-mode files as all the extra asterisks in the headings wil be hidden leading to more empty white space and a cleaner look.

#+begin_src emacs-lisp :noweb-ref org_customize
  (org-startup-indented t)
#+end_src

**** Native Tabs

This will allow for source code blocks in emacs org-mode to be internally indented as they would normally be in their majors modes.

#+begin_src emacs-lisp :noweb-ref org_customize
  (org-src-tab-acts-natively t)
 #+end_src
 
*** Change TODO Keyword Colors

Change the color of the org-todo keywords to make it easier to see them on a color screen and distinguish between them.

#+begin_src emacs-lisp :noweb-ref org_customize
  (org-todo-keyword-faces
   '(("TODO" . org-warning)
     ("WAITING" . "yellow")
     ("CANCELED" . (:foreground "blue" :weight bold))
     ("DONE" . org-done)))
#+end_src

*** Capturing Ideas

Org-capture templates make creating org-mode notes quicker and easier from any buffer using a standard template for each not type.

#+name: org_capture_templates
#+begin_src emacs-lisp :noweb-ref org_customize
   (org-capture-templates
    '(("p" "Projects item" entry (file "~/Dropbox/gtd/projects.org")
       "* %? :project:")
      ("s" "Someday/Maybe item" entry (file "~/Dropbox/gtd/someday.org")
       "* %?\n%x")
      ("T" "Tickler file item" entry (file "~/Dropbox/gtd/tickler.org")
       "* %?\n%^{Scheduled}t\n%x")
      ("t" "To Do Item" entry (file+headline "~/Dropbox/gtd/inbox.org" "Tasks")
       "* TODO %? %^G\nSCHEDULED: %^{Scheduled}t DEADLINE: %^{Deadline}t\n%x")))
#+end_src

** Org-mind-map

Org-mind-map (https://github.com/the-ted/org-mind-map) turns any ~org-mode~ buffer into a mind map in various output formats.

#+begin_src emacs-lisp :tangle yes
  (use-package org-mind-map
    :straight t
    :after org
    :commands org-mind-map-write
    :init
    (require 'ox-org)
    :custom
    (org-mind-map-engine "dot"))
#+end_src

** Org-ref

Org-ref (https://github.com/jkitchin/org-ref) is a reference manager in org-mode.

#+begin_src emacs-lisp :tangle yes
  (use-package org-ref
    :straight t
    :defer t
    :after org)
#+end_src

** Org-roam

Org-roam (https://www.orgroam.com/) adds features to make linking org notes easier and provided a database file to connect all the notes together.

#+begin_src emacs-lisp :tangle yes
  (use-package org-roam
    :straight t
    :defer t
    :after org
    :init
    (setq org-roam-v2-ack t) ;; Acknowledge V2 upgrade
    :custom
    (org-roam-directory (file-truename "~/Dropbox/org-roam"))
    :config
    (org-roam-setup)
    :custom
    (org-roam-dailies-directory "daily/")
    (org-roam-capture-templates
     '(("d" "default" plain "%?"
        :target (file+head "${slug}.org"
                           "#+title: ${title}\n")
        :unnarrowed t)))
    (org-roam-dailies-capture-templates
     '(("d" "default" entry
        "* %?"
        :target (file+head "%<%Y-%m-%d>.org"
                           "#+title: %<%Y-%m-%d>\n"))))
    :bind
    (("C-c n f" . org-roam-node-find)
     ("C-c n g" . org-roam-graph)
     ("C-c n r" . org-roam-node-random)		    
     (:map org-mode-map
           (("C-c n i" . org-roam-node-insert)
            ("C-c n o" . org-id-get-create)
            ("C-c n t" . org-roam-tag-add)
            ("C-c n a" . org-roam-alias-add)
            ("C-c n l" . org-roam-buffer-toggle)))))
#+end_src

* Writing/Publishing/Reading

** Academic Phrases

[[https://github.com/nashamri/academic-phrases][Academic phrases]] is a package that provides a number of easy-to-use templates for writing academic text if you happen to have writer's block. Calling the function ~M-x academic-phrases~ provides a searchable list of these templates for your use.

#+begin_src emacs-lisp :tangle yes
  (use-package academic-phrases
    :straight t
    :defer t)
#+end_src

** AUCTeX :LaTeX:

[[https://www.gnu.org/software/auctex/][AUCTeX]] for writing documents using LaTeX.

#+begin_src emacs-lisp :tangle yes :noweb yes
    (use-package auctex
      :straight t
      :defer t
      :custom
      (TeX-auto-save t)
      (TeX-parse-self t)
      (TeX-master nil)
      <<auctex_custom>>)
#+end_src

*** Use BibLaTeX

BibLaTeX has more powerful features than standard BibTeX.

#+begin_src emacs-lisp :noweb-ref auctex_custom
(bibtex-dialect 'biblatex)
#+end_src

** Flyspell

Flyspell mode can be hooked to various buffer modes so that spell-checking can be done as typing occurs. As you type, a red wavy line will appear under text that it deems to be incorrectly spelled.

In order for this to work in Windows, hunspell must be installed with the proper dictionaries. I have downloaded hunspell from ezwinports and included it in my ~~/.emacs.d/~ directory so that I can also use hunspell when I am using Emacs as a portable app from a USB drive.

#+begin_src emacs-lisp :tangle yes
  (use-package ispell
    :defer t
    :config
    (if (eq system-type 'windows-nt)
      (progn (setq ispell-program-name (expand-file-name "~/.emacs.d/hunspell/bin/hunspell.exe"))
             (setq ispell-personal-dictionary "~/.emacs.d/hunspell_en_US")
             (setq ispell-local-dictionary "en_US")
             (setq ispell-local-dictionary-alist
                   '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8))))
        (setq ispell-program-name (whicher "hunspell"))))
#+end_src

#+begin_src emacs-lisp :tangle yes
  (use-package flyspell
    :defer t
    :init
    (add-hook 'prog-mode-hook 'flyspell-prog-mode)
    (add-hook 'text-mode-hook 'flyspell-mode))
#+end_src

** PDF Tools

[[https://github.com/politza/pdf-tools][PDF Tools]] is a faster and more feature-rich than the built in DocView.

#+begin_src emacs-lisp :tangle yes
  (use-package pdf-tools
    :straight t
    :magic ("%PDF" . pdf-view-mode)
    :config
    (pdf-loader-install :no-query))
#+end_src

** Single Space at the End of Sentences

Emacs when navigating expects sentences to end with a double space after a period. While this makes documents written in plain text to look more attractive and more readable, this convention is not used much anymore and this will break emacs commands for killing and navigating sentences.

#+begin_src emacs-lisp :noweb-ref emacs_custom
  (sentence-end-double-space nil)
#+end_src

* Shells

** Eshell

Eshell is a very powerful lisp-based shell that I have learned to love most because you can redirect output directly to Emacs buffers. This feature has made it my default shell and I have switched to it from using mostly Z shell because I send stuff to and from Emacs buffers. This feature really is a game changer.

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package eshell
    :defer t
    :hook
    <<eshell_prompt>>
    (eshell-mode . (lambda ()
                     <<eshell_visual_commands>>
                     <<eshell_aliases>>))
    :custom
    (eshell-error-if-no-glob t)
    (eshell-hist-ignoredups t)
    (eshell-save-history-on-exit t)
    (eshell-destroy-buffer-when-process-dies t)
    :config
    (setenv "PAGER" "cat"))
  #+end_src
  
*** Eshell Aliases

Below are a list of command-line aliases for use in eshell.

#+name: eshell_aliases
#+begin_src emacs-lisp :noweb-ref eshell_aliases
  (eshell/alias "ff" "find-file $1")
  (eshell/alias "emacs" "find-file $1")
  (eshell/alias "untar" "tar -zxvf")
  (eshell/alias "cpv" "rsync -ah --info=progress2")
  (eshell/alias "ll" "ls -Alh")
#+end_src

*** Eshell Visual Commands

Many commands when run in eshell turn into a mess as it is not an ansi-term. Any interactive commands that need the full ansi-term to display properly are listed below so that when they are run from the eshell they will open in ansi-tem and display properly.

#+name: eshell_visual_commands
#+begin_src emacs-lisp :noweb-ref eshell_visual_commands
  (add-to-list 'eshell-visual-commands "htop")
  (add-to-list 'eshell-visual-commands "ipython")
  (add-to-list 'eshell-visual-commands "rclone")
  (add-to-list 'eshell-visual-commands "ssh")
  (add-to-list 'eshell-visual-commands "tail")
  (add-to-list 'eshell-visual-commands "top")
#+end_src

** Eshell Git Prompt

[[https://github.com/xuchunyang/eshell-git-prompt][eshell-git-prompt]] provides a series of Eshell prompts that provide extra information including the git status of the current project.

#+begin_src emacs-lisp :tangle yes
  (use-package eshell-git-prompt
    :straight (emacs-git-prompt :host github
                                :repo "tfree87/eshell-git-prompt"
                                :branch "master")
    :defer t)
#+end_src

*** Set the Eshell prompt on load

This method was the only method I have found that loaded the ~eshell-git-prompt~ immediately when Eshell was loaded.

#+begin_src emacs-lisp :noweb-ref eshell_prompt
  (eshell-load . (lambda ()
                        (eshell-git-prompt-use-theme 'multiline2)))
#+end_src
** Eshell Toggle

[[https://github.com/4DA/eshell-toggle][eshell-toggle]] makes it easy to pull up a temporary Eshell buffer for running commands quickly from the working directory of that buffer.

#+begin_src emacs-lisp :tangle yes
  (use-package eshell-toggle
    :straight (eshell-toggle :repo "4DA/eshell-toggle"
                             :host github
                             :repo "master")
    :custom
    (eshell-toggle-size-fraction 3)
    (eshell-toggle-run-command nil)
    (eshell-toggle-init-function #'eshell-toggle-init-eshell)
    :bind
    ("M-s-`" . eshell-toggle))
#+end_src

** PowerShell :Windows:

[[https://github.com/jschaf/powershell.el][Powershell.el]] creates a function that will launch an inferior shell that will run the Windows PowerShell tool.

#+begin_src emacs-lisp :tangle yes
  (use-package powershell
    :if (eq system-type 'windows-nt)
    :defer t
    :init
    (whicher "powershell.exe")
    :straight t
    :config
    ;; Change default compile command for powershell
    (add-hook 'powershell-mode-hook
              (lambda ()
                (set (make-local-variable 'compile-command)
                     (format
                      (whicher
                       "powershell.exe -NoLogo -NonInteractive -Command \"& '%s'\"")
                      (buffer-file-name))))))
#+end_src

* Theme and Appearance
** All the Icons

[[https://github.com/domtronn/all-the-icons.el][All The Icons]] adds some graphical elements to dired and the minibuffer. I find it makes it easier to see what types of files are being listed and it is just fun too.

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package all-the-icons
    :if (not <<portable_check>>)
    :defer t
    :straight t)
#+end_src

** All the Icons Dired

[[https://github.com/jtbm37/all-the-icons-dired][all-the-icons-dired]] will add file-type icons to Dired while browsing files and directories. I find this very helpful to quickly have visual cues to find the correct files in the Dired buffer.

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package all-the-icons-dired
    :if (not <<portable_check>>)
    :straight t
    :hook
    (dired-mode . all-the-icons-dired-mode))
 #+end_src
 
** All the Icons Ibuffer

[[https://github.com/seagle0128/all-the-icons-ibuffer][all-the-icons-ibuffer]] adds icons representing different buffer types to Ibuffer mode.

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package all-the-icons-ibuffer
    :if (not <<portable_check>>)
    :straight t
    :hook (ibuffer-mode . all-the-icons-ibuffer-mode))
#+end_src

** All the Icons Completion

[[https://github.com/iyefrat/all-the-icons-completion][all-the-icons-completion]] adds icons for many Emacs minibuffer completion systems so that files and directories will have icons in the minibuffer when called with ~C-x C-f~ and other similar commands.

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package all-the-icons-completion
    :if (not <<portable_check>>)
    :straight t
    :defer 3
    :config
    (all-the-icons-completion-mode)
    (add-hook 'marginalia-mode-hook #'all-the-icons-completion-marginalia-setup))
#+end_src

** Centaur Tabs

I like having tabs for all of my open buffers. [[https://github.com/ema2159/centaur-tabs][Centaur Tabs]] provides a nicer interface than the built-in ~tab-line-mode~. I rarely use this package, however, as I find the built-in ~tab-bar-mode~ plays better with mutli-window setups.

#+begin_src emacs-lisp :tangle yes
  (use-package centaur-tabs
    :if window-system
    :straight t
    :defer t
    :bind
    ("C-<prior>" . centaur-tabs-backward)
    ("C-<next>" . centaur-tabs-forward)
    :custom
    (centaur-tabs-set-bar 'over)
    (centaur-tabs-style "chamfer")
    :config
    (centaur-tabs-mode t))
#+end_src

This setting can always be toggled off if a "cleaner" Emacs view is desired.
** Display Time

This will display the time in the Emacs mode line. This can be very useful if task bars are hidden on the desktop or working from a text-only terminal.

#+begin_src emacs-lisp :noweb-ref emacs_custom
  (display-time-mode t)
#+end_src

When I am running Emacs with EXWM as my window manager, I want to be able to see the date and time. Since this is a nice feature to have in EXWM and does not detract much from the overall experience of Emacs, I might as well turn it on all the time.

#+begin_src emacs-lisp :noweb-ref emacs_custom
  (display-time-and-date t)
#+end_src

** Doom Themes

I have switched to the Doom theme ~doom-outrun-electric~ because I find the colors appealing and it has been easier to configure than my earlier attempts to configure a Spacemacs-like theme.

#+begin_src emacs-lisp :tangle yes
  (use-package doom-themes
    :if window-system
    :straight t
    :defer 1
    :config
    (load-theme 'doom-outrun-electric t)
    (doom-themes-org-config))
#+end_src

** Doom Modeline

The Doom Modeline decorates the modeline with icons and cleans up much of the clutter in the modeline.  An example of the Doom Modeline is below.

[[file:./screenshots/doom-modeline.png][./screenshots/doom-modeline.png]]

#+begin_src emacs-lisp :tangle yes
  (use-package doom-modeline
    :if window-system
    :straight t
    :defer 1
    :config (doom-modeline-mode))
#+end_src

** Menu Bar, Scroll Bar, and Tool Bar

Turn off the menu bar, scroll bar, and tool bar because it looks so darn cool and I tend to use the keyboard for everything now anyways.

#+begin_src emacs-lisp :noweb-ref emacs_config
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (toggle-scroll-bar -1)
#+end_src

** Minions

Minor mode lighters in Emacs become very cumbersome in the modeline when many minor modes are turned on simultaneously. This happens very often with any highly configured Emacs. With too much information in the modeline and a number of minor modes getting cut off in the display, this feature is no longer helpful for information about the current buffer.

Minions is a package that puts all of the minor modes into a menu in the modeline so that all minro modes can be displayed and viewed in this menu. This can be very helpful as it provides access to a list of all the enabled minor modes while consolidating information on the modeline and removes the need for packages such as blackout, delight, dim, and diminish.

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package minions
    :if <<use_minions>>
    :defer 4
    :config
    (minions-mode 1))
#+end_src

Minions mode does not work when ~doom-modeline-mode~ is not active. It appears that ~doom-modeline-mode~ overwrites the settings changed when ~doom-modeline-mode~ is activated. To prevent Minions from slowing down Emacs startup time, the following check can be used to prevent it from being loaded if Doom Modeline is active:

#+begin_src emacs-lisp :noweb-ref use_minions
  (not (bound-and-true-p doom-modeline-mode))
#+end_src

** Mixed Pitch

Mixed pitch mode is a package that makes it easy to use a combination of fixed-width and variable-width fonts in the same buffer. I use this with Org Mode to use different file types for prose and and for source code blocks.

#+begin_src emacs-lisp :tangle yes
  (use-package mixed-pitch
    :straight t
    :hook
    (org-mode . mixed-pitch-mode))
#+end_src

** Nyan Mode

[[https://github.com/TeMPOraL/nyan-mode][Nyan-mode]] displays a nyan cat on the mode line that shows progress through a buffer.

#+begin_src emacs-lisp :tangle yes
  (use-package nyan-mode
    :if window-system
    :straight t
    :defer 3
    :init
    ;; Requires mplayer to play the music
    (whicher "mplayer")
    :custom
    (nyan-wavy-trail t)
    :config
    (nyan-mode)
    (nyan-start-animation))
#+end_src

** Olivetti

Olivetti is a minor mode that can be used to center text in a buffer t make it more pleasant to read. It creates margins that are similar to the large margins you might find in a default class of a LaTeX document. I have found that large margins make reading much more pleasant.

#+begin_src emacs-lisp :tangle yes
  (use-package olivetti
    :straight t
    :hook
    (org-mode . olivetti-mode))
#+end_src

** Org Superstar Mode :org:

Org Superstar Mode turns the stars/asterisks in Org Mode into nicely formatted bullets. What separates it from Org Bullets is that Org Superstar Mode also can support plain lists and it has the option to format TODO keywords.

#+begin_src emacs-lisp :tangle yes :noweb yes
    (use-package org-superstar
      :straight t
      :after org
      :custom
      (org-superstar-prettify-item-bullets t)
      (org-superstar-item-bullet-alist '((?* . ?•)
                                         (?+ . ?➤)
                                         (?- . ?•)))
      :hook
      (org-mode . org-superstar-mode))
#+end_src

** Org Header Sizes :org:

The following custom function will change the heading sizes in Org Mode to make it easier to see the different heading levels. In addition, this will also increase the size of the document title and make it more prominent. This code is modified and from [[https://github.com/daviwil][@daviwil]] from [[https://github.com/daviwil/emacs-from-scratch/blob/master/show-notes/Emacs-05.org#improving-the-look][this link]].

#+begin_src emacs-lisp :tangle yes
  (defun fm/org-header-formatting ()
    (interactive)
    (with-eval-after-load 'org
      (dolist
          (face
           '((org-level-1 . 1.75)
             (org-level-2 . 1.50)
             (org-level-3 . 1.25)
             (org-level-4 . 1.10)
             (org-level-5 . 1.10)
             (org-level-6 . 1.10)
             (org-level-7 . 1.10)
             (org-level-8 . 1.10)
             (org-document-title . 2.00)))
        (set-face-attribute (car face) nil :height (cdr face)))))
#+end_src

* Other

** EMMS

EMMS is a multimedia player for Emacs.

#+begin_src emacs-lisp :tangle yes
  (use-package emms
    :straight t
    :defer t
    :custom
    (emms-source-file-default-directory "~/Music/")
    :config
    (require 'emms-setup)
    (emms-all)
    (emms-default-players)
    (global-set-key (kbd "<XF86AudioPrev>") 'emms-previous)
    (global-set-key (kbd "<XF86AudioNext>") 'emms-next)
    (global-set-key (kbd "<XF86AudioPlay>") 'emms-pause))
#+end_src

** BBDB

The [[https://www.jwz.org/bbdb/][Insidious Big Brother DataBase]], also known as BBDB, is used to store contact information in Emacs and interfaces with many other Emacs packages such as Gnus and Org-mode.

#+begin_src emacs-lisp :tangle yes
  (use-package bbdb
    :straight t
    :defer t
    :hook
    (gnus-summary-mode . (lambda ()
                           (define-key gnus-summary-mode-map
                             (kbd ";")
                             'bbdb-mua-edit-field)))
    :custom
    (bbdb-file "~/Dropbox/bbdb.el")
    (bbdb-use-pop-up 'horiz)
    (bbdb-mua-update-interactive-p '(query . create))
    (bbdb-message-all-addresses t)
    :config
    (bbdb-mua-auto-update-init 'gnus 'message))
#+end_src

** Docker

[[https://github.com/Silex/docker.el][Docker mode]] is an interface in Emacs to manage Docker containers.

#+begin_src emacs-lisp :tangle yes
  (use-package docker
    :init
    (whicher "docker")
    :straight t
    :bind ("C-c d" . docker))
#+end_src

** Docker Compose

[[https://github.com/meqif/docker-compose-mode][docker-compose-mode]] is a major mode for editing Docker Compose files.

#+begin_src emacs-lisp :tangle yes
  (use-package docker-compose-mode
    :defer t
    :straight t
    :init
    (whicher "docker-compose"))
#+end_src

** Gnuplot

[[https://github.com/emacs-gnuplot/gnuplot][Gnuplot]] mode can be used for editing files that are used to define a plot style and layout and allow for execution of the code in an Emacs buffer.

#+begin_src emacs-lisp :tangle yes
    (use-package gnuplot
      :init
      (whicher "gnuplot")
      :straight t
      :defer t)
#+end_src

** Helpful

[[https://github.com/Wilfred/helpful][Helpful]] improves the Emacs help functions by adding new features to the ~*Help*~ buffers such as:

- Links to source code
- Better formatting of docstrings
- Lists of callers
- Keymaps
- Aliases
- And more...

#+begin_src emacs-lisp :tangle yes
  (use-package helpful
    :straight t
    :defer t
    :bind
    ("C-h f" . #'helpful-callable)
    ("C-h v" . #'helpful-variable)
    ("C-h k" . #'helpful-key)
    ("C-c C-d" . #'helpful-at-point)
    ("C-h F" . #'helpful-function)
    ("C-h C" . #'helpful-command))
#+end_src

** Ibuffer

A better buffer list than the default.

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package ibuffer
    :bind
    ("C-x C-b" . ibuffer)
    :custom
    <<ibuffer_custom>>
    :config
    <<ibuffer_config>>)
#+end_src

*** Group Buffers

Ibuffer makes it possible to sort buffers in the buffer list into groupings. This makes is a lot faster for me to find a particular buffer that I want to switch to.

1. First we need to start ibuffer with default groupings:
   
#+begin_src emacs-lisp :noweb-ref ibuffer_config
  (add-hook 'ibuffer-mode-hook
            (lambda ()
              (ibuffer-switch-to-saved-filter-groups
               "default")))
#+end_src

2. Then we need to define our groups for ibuffer:
   
#+begin_src emacs-lisp :noweb-ref ibuffer_custom
  (ibuffer-saved-filter-groups
   '(("default"
      ("Dired" (mode . dired-mode))
      ("Emacs" (or
                (name . "^\\*scratch\\*$")            
                (name . "^\\*Messages\\*$")
                (name . "^\\*GNU Emacs\\*$")
                (name . "^\\*Help\\*$")
                (name . "^\\*Calendar\\*$")
                (name . "^\\*Calculator\\*$")
                (name . "^\\*Calc Trail\\*$")
                (name . "^\\*Completions\\*$")))
      ("Gnus" (or
               (mode . message-mode)
               (mode . bbdb-mode)
               (mode . mail-mode)
               (mode . gnus-group-mode)
               (mode . gnus-summary-mode)
               (mode . gnus-article-mode)
               (name . "^\\.bbdb$")
               (name . "^\\.newsrc-dribble")))
      ("Org"   (or
                (mode . org-mode)
                (name . "^\\*Org Agenda\\*$")))
      ("Shell"   (or
                  (mode . eshell)
                  (mode . term)
                  (mode . shell))))))
#+end_src

** Ledger

To conduct plain-text accounting in Emacs, [[https://github.com/ledger/ledger-mode][ledger-mode]] needs to be installed from the package repositories. This mode will create faces for the text and highlight transactions while also providing the functionality to execute ledger reports in an Emacs buffer. No shell needed.

#+begin_src emacs-lisp :tangle yes
    (use-package ledger-mode
      :straight t
      :defer t
      :init
      (whicher "ledger"))
#+end_src

** Multiple Cursors

[[https://github.com/magnars/multiple-cursors.el][multiple-cursors.el]] allows for editing Emacs buffers at multiple locations simultaneously at the same time and has transformed how I use Emacs dired. I can use it to edit many file names at once in a directory by making any dired buffer editable by pressing =C-x C-q=.
#+begin_src emacs-lisp :tangle yes
  (use-package multiple-cursors
    :straight t
    :defer t
    :bind
    ("C-S-c C-S-c" . 'mc/edit-lines)
    ("C->" . 'mc/mark-next-like-this)
    ("C-<" . 'mc/mark-previous-like-this)
    ("C-c C-<" . 'mc/mark-all-like-this))
#+end_src

** PlantUML

[[https://plantuml.com/][PlantUML]] is a language that can interpret code to create flowcharts and UML diagrams. The syntax is similar to programming languages thereby making it fast and easy to create accurate, auto-generated charts that don't require a lot of dragging boxes around as you might with a graphical tool such as LibreOffice Draw.

*** Install PlantUML Mode

[[https://github.com/skuro/plantuml-mode][PlantUML mode]] is not installed by default, so we need ~use-package~ to download and install it.

#+begin_src emacs-lisp :tangle yes
  (use-package plantuml-mode
    :straight t
    :defer t
    :after org)
#+end_src

*** Set Location of PlantUML Binary

When Emacs is run as a portable app on a USB drive, Emacs needs to know the location of the PlantUML executable which I place in the .emacs.d directory.

#+begin_src emacs-lisp :noweb-ref org_customize
  (org-plantuml-jar-path (expand-file-name "~/.emacs.d/plantuml/plantuml.jar"))
#+end_src

** Popper

[[https://github.com/karthink/popper][Popper]] lets a user define any window as a short-term pop up window.

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package popper
    :straight t
    :bind (("C-`"   . popper-toggle-latest)
           ("M-`"   . popper-cycle)
           ("C-M-`" . popper-toggle-type))
    :init
    <<popper_init>>
    (popper-mode +1)
    (popper-echo-mode +1))
#+end_src

*** Popper Buffer Buffers

For each buffer that will become a popper pop up buffer, it must be defined below:

#+begin_src emacs-lisp :noweb-ref popper_init
  (setq popper-reference-buffers
          '("\\*Messages\\*"
            "\\*Embark Actions\\*"
            "Output\\*$"
            "\\*Async Shell Command\\*"
            "\\*Whicher Report\\*"
            help-mode
            compilation-mode))
#+end_src

** Savehist

Savehist will save the selections from completion history between Emacs sessions. This makes it so that commonly used commands and files will float to the top of the minibuffer in [[Vertico]].

#+begin_src emacs-lisp :tangle yes
  (use-package savehist
    :straight t
    :init
    (savehist-mode))
  #+end_src
  
** Which-key
[[https://github.com/justbur/emacs-which-key][Which-key]] provides a pop-up menu when there is a pause in the minibuffer or if executed directly to show the keyboard commands available to the current buffer.

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package which-key
    :straight t
    :defer 3
    :custom
    <<wk_custom>>
    :config
    <<wk_config>>
    (which-key-mode))
#+end_src

*** Activating Which-key

How to start which-key

**** C-h During Key Combination Entry

Type C-h during any key combination to pop-up which key

#+begin_src emacs-lisp :noweb-ref wk_custom
  (which-key-show-early-on-C-h t)
#+end_src

**** Press <f4> in Any Mode

Use the <f4> key in any major mode to see the key bindings

#+begin_src emacs-lisp :noweb-ref wk_config
  (global-set-key (kbd "<f4>") 'which-key-show-major-mode)
#+end_src

*** Which-key Window Location

Set up which-key to use the side window preferably

#+begin_src emacs-lisp :noweb-ref wk_config
  (which-key-setup-side-window-right-bottom)
#+end_src

** YASnippet

YASnippet is a system that povides easy access to many templates that can be inserted into buffers based on their major mode.

*** Install YASnippet

[[https://github.com/joaotavora/yasnippet][YASnippet]] takes a small bit of text or an abbreviation and expands it into a template once the ~<TAB>~ key has been pressed. This is very useful for typing sections of text that are repeated often such as creating the =#+begin_src emacs-lisp :tangle yes= blocks in this Org-mode file such as the one below.

#+begin_src emacs-lisp :tangle yes
  (use-package yasnippet
    :straight t
    :defer 3
    :config
    (yas-global-mode 1))
#+end_src

*** Install Snippets

The package [[https://github.com/AndreaCrotti/yasnippet-snippets][YASnippet Snippets]] loads many pre-defined templates for YASnippet. This is very useful as many of the best use cases for YASnippet are already included in this package making reducing the need to create individual custom templates.

#+begin_src emacs-lisp :tangle yes
  (use-package yasnippet-snippets
    :straight t
    :defer t)
#+end_src

* Emacs Desktop

When there is no window manager running, Emacs can run as a window manger using EXWM. This makes for a very lean desktop environment where all programs-including X11 applications-are run in Emacs windows and can be controlled by commands that control Emacs windows. Emacs Desktop also adds some extra convenience features.

** Check for Window Manager

I generally only want to use EXWM when I do not have another window manger in place. The following check will use ~wmctrl -m~ to check if there is an active window manager running. If it finds a window manager running, the exit code will be 0. If not, the exit code will be 1. Calling ~echo $?~ immediately afterward with ~shell-command-to-string~ will return the exit code appended to the end of the output from ~wmctrl -m~. As we only care about the status of the exit code, we can call on the ~substring~ function to get just the exit code and not the whole output of the command.

There is also a check for the X window system as calling GUI programs from EXWM will not work without it.

#+begin_src emacs-lisp :noweb-ref win_man_check
  (and (not
        (string=
         (substring
          (shell-command-to-string
           "wmctrl -m ; echo $?")
          -2 -1) "0"))
       (eq window-system 'x))
#+end_src

** App Launcher

Use App Launcher to launch Linux applications in EXWM. App Launcher will scan for all ~*.desktop~ files in the application directories on Linux and provide a list of candidates that can be filtered with completion.

#+begin_src emacs-lisp :tangle yes
  (use-package app-launcher
    :straight '(app-launcher :host github
                             :repo "SebastienWae/app-launcher"
                             :branch "main")
    :commands (app-launcher))
#+end_src

*** TODO Create a fork of app-launcher and add support for Windows applications using the Windows start menu shortcuts directory

** EXWM

To use EXWM, the EXWM package can be pulled from using ~straight.el~.

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package exwm
    :straight t
    :if
    <<win_man_check>>
    :custom
    <<exwm_custom>>
    :config
    <<exwm_config>>    
    (exwm-enable))
#+end_src

*** Battery Mode

When running EXWM as the only window manager, turning on ~display-battery-mode~ will make it so the battery power on a laptop or portable device can be monitored.

#+begin_src emacs-lisp :noweb-ref exwm_config
  (display-battery-mode t)
#+end_src

*** Buffer Naming

To name buffers based on the application that was launched to create them, the following code must be used:

#+begin_src emacs-lisp :noweb-ref exwm_config
  (add-hook
   'exwm-update-class-hook (lambda()
                             (exwm-workspace-rename-buffer
                              exwm-class-name)))
#+end_src

*** Default Workspaces

With only a single monitor at the moment I only see the need for a single workspace as I can switch between tasks by switching buffers. This number should be increased with more monitors, however, as each workspace can display in a separate monitor and switching can then be done easily with the keyboard.

#+begin_src emacs-lisp :noweb-ref exwm_custom
  (exwm-workspace-number 1)
#+end_src

*** Keys

It is extremely helpful to set up special keybindings for use in EXWM due to the fact that X11 applications won't see keyboard commands that are first intercepted by Emacs.

**** Global Keys

These key bindings will always work, regardless of whether the current buffer is in ~char-mode~ or ~line-mode~. Since these keybindings always work, it is best to use a prefix key such as the ~super~ key.

#+begin_src emacs-lisp :noweb yes :noweb-ref exwm_custom
  (exwm-input-global-keys
   `(<<char_line_switch>>
     <<window_switching>>
     <<launch>>))
#+end_src

***** Launching Programs

The following command can be used to launch programs in EWXM by using the command ~s-e~. This will call the ~app-launcher-run-app~ function from the [[App Launcher]] package.

#+begin_src emacs-lisp :noweb-ref launch
  ([?\s-e] . app-launcher-run-app)
#+end_src

***** Moving

To have a universal command to switch between windows in EXWM, the super key and the arrow keys can be used to move about the windows directionally. Ace Window Mode doesn't work with X11 application windows, so it is convenient to have these keys set up.

#+begin_src emacs-lisp :noweb-ref window_switching
  ([s-left] . windmove-left)
  ([s-right] . windmove-right)
  ([s-up] . windmove-up)
  ([s-down] . windmove-down)
#+end_src

The following command can also be used to select a workspace if multiple workspaces are created.

#+begin_src emacs-lisp :noweb-ref window_switching
  ([?\s-w] . exwm-workspace-switch)
#+end_src

***** Switching Between ~char-mode~ and ~line-mode~

When using EXWM, opening an X11 application will load in ~line-mode~ by default. This means that switching to a buffer containing an X11 application such (e.g. Firefox), that ~C-c~ will act as an Emacs prefix command. Pressing ~C-c C-k~ will switch to ~char-mode~ and ~C-c~ will then do the usual copy command. Pressing ~s-r~ retruns back to ~line-mode~.

#+begin_src emacs-lisp :noweb yes :noweb-ref char_line_switch
  ([?\s-r] . exwm-reset)
#+end_src

**** ~input-send-next-key~

Any keys that Emacs recognizes as a prefix key, will not be passed to any underlying X11 applications running in an Emacs window. If a specific key (i.e. ~C-c~ for copy) needs to be sent to the X11 application, a prefix key can be set as ~exwm-input-send-next-key~ and issued before calling the key.

For example, to copy and paste from an X11 application running in an Emacs window, one could press ~C-q C-c~ to copy text and ~C-q C-v~ to paste text.

#+begin_src emacs-lisp :noweb-ref exwm_config
(define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)
#+end_src

**** Input Prefix

Setting ~exwm-input-prefix-keys~ will cause those keys to be passed directly to Emacs to be processed. These keys will not be passed to any app unless they are proceeded by the ~exwm-input-send-next-key~.

#+begin_src emacs-lisp :noweb-ref exwm_custom
  (exwm-input-prefix-keys
   '(?\C-x
     ?\C-u
     ?\C-h
     ?\M-x
     ?\M-`
     ?\M-&
     ?\M-:
     ?\C-\M-j
     ?\C-\ ))
#+end_src

*** RandR

For multi-screen displays, ~exwm-randr~ must be enabled.

#+begin_src emacs-lisp :noweb-ref exwm_config
  (require 'exwm-randr)
  (exwm-randr-enable)
#+end_src

*** SystemTray

Make sure to turn on the system tray in EXWM so that there is access to tray icons.

#+begin_src emacs-lisp :noweb-ref exwm_config
  (require 'exwm-systemtray)
  (exwm-systemtray-enable)
#+end_src

**** Wifi

To enable a wifi applet in the ~exwm-system-tray~, Emacs can execute the ~nm-applet~ if it is installed.

#+begin_src emacs-lisp :noweb-ref exwm_config
  (whicher "nm-applet")
  (when (executable-find "nm-applet")
    (start-process-shell-command "nm-applet" nil "nm-applet"))

#+end_src

**** Dropbox

To get Dropbox running with the Dropbox applet, start Dropbox after EXWM has loaded.

#+begin_src emacs-lisp :noweb-ref exwm_config
  (whicher "dropbox")
  (when (executable-find "dropbox")
    (start-process "dropbox" nil "dropbox" "start"))

#+end_src

** Desktop Environment

The desktop environment package makes it so that some of the features that are included in a typical desktop environment system are included in EXWM. This includes features such as access to media buttons, a screen locker, and adjustable brightness from the keyboard.

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package desktop-environment
    :straight t
    :init
    (mapc #'whicher '("brightnessctl"
                     "amixer"
                     "scrot"
                     "slock"
                     "upower"
                     "TLP"
                     "playerctl"))
    :after exwm
    :custom
    <<amixer>>
    :config (desktop-environment-mode))
#+end_src

*** Set Audio Mixer Command

To use the volume controls with with Desktop Environment mode, the command for amixer may need to be set to find the proper audio channel to set. The device can be set wih the ~-c~ option.

#+begin_src emacs-lisp :noweb-ref amixer
  (desktop-environment-volume-get-command "amixer -c 1 get Master")
  (desktop-environment-volume-set-command "amixer -c 1 set Master %s")
  (desktop-environment-volume-toggle-command "amixer -c 1 set Master toggle")
#+end_src

** Tap to Click

To ensure that the touchpad allows will take tapping as a click, activate it with the shell command ~xinput set-promp "SynPS/2 Synaptics Touchpad" "libinput Tapping Enabled" 1~. While we are doing this, we might as well tell Whicher that we need ~xinput~ installed.

#+begin_src emacs-lisp :noweb-ref exwm_config
  (shell-command
   (concat
    (whicher "xinput")
    " set-prop \"SynPS/2 Synaptics TouchPad\""
    " \"libinput Tapping Enabled\" 1"))
#+end_src

* Emacs Server

Running Emacs as a server means that if I create a new instance of Emacs with the command ~emacs~, I can then use the command ~emacsclient -c -n~ in order to quickly open a new Emacs buffer that is part of the same Emacs session.

I have this option run only when I am not executing Emacs as a portable app as it is unlikely that there will be Emacs installed on the system that I am running Emacs on when I am using it portably.

#+begin_src emacs-lisp :tangle yes :noweb yes
  ;; Start an Emacs server
  
  (when (not <<portable_check>>)
    (server-start))
#+end_src

* Custom Functions

This section contains custom functions that I have either created myself or borrowed from others to accomplish small tasks.

#+begin_src emacs-lisp :tangle yes
;; Custom Function Definitions
#+end_src

** Oh My Eshell

Something I am fiddling around with...

#+begin_src emacs-lisp :tangle yes
  ;; (load-file "~/.emacs.d/elisp/oh-my-esh.el")
#+end_src

** Rclone Sync

The following function will execute the rclone command line tool:

#+begin_src emacs-lisp :tangle yes
    (defun rclone-sync (source dest &optional rclone-path rclone-config)
    "Sync DEST with SOURCE using rclone.
    The path to the rlcone executable can be set with RCLONE-PATH.
    The rclone configuration can be set with RCLONE-CONFIG."
    (interactive)
    (message
     (let ((rclone-path (or rclone-path "rclone"))
           (rclone-config (or rclone-config nil))
           (config-option
            (if rclone-config
                (concat " --config " rclone-config)
              (nil))))
       (concat rclone-path
               config-option
               " -vP sync "
               source
               " "
               dest))))
#+end_src

** Sudo Find File

This function creates a ~sudo-find-file~ command that can be used to open files as the super user. This can be really useful when combined with Embark. This function was copied from https://karthinks.com/software/fifteen-ways-to-use-embark/.

#+begin_src emacs-lisp :tangle yes
  (whicher "sudo")
  (defun sudo-find-file (file)
      "Open FILE as root."
      (interactive "FOpen file as root: ")
      (when (file-writable-p file)
        (user-error "File is user writeable, aborting sudo"))
      (find-file (if (file-remote-p file)
                     (concat "/" (file-remote-p file 'method) ":"
                             (file-remote-p file 'user) "@" (file-remote-p file 'host)
                             "|sudo:root@"
                             (file-remote-p file 'host) ":" (file-remote-p file 'localname))
                   (concat "/sudo:root@localhost:" file))))
#+end_src

* Update Org Files on Portable App Startup

When running Emacs as a portable app, I want to pull down the latest versions of my ~org-agenda-files~ and other Org Mode files onto my USB flash drive (which has been set as the home directory). I also want to make sure to update the remote location when Emacs is killed so that all of my changes will be synced with the cloud and available for use on other systems.

#+begin_src emacs-lisp :tangle yes :noweb yes
  ;; Sync Dropbox containing org agenda files on load and close

  (when <<portable_check>>
    (let ((rclone-remote "dropbox:")
          (rclone-local "~/Dropbox")
          (rclone-path  "~/rclone/rclone.exe")
          (rclone-conf "~/rclone/rclone.conf"))
      (rclone-sync rclone-remote
                   rclone-local
                   rclone-path
                   rclone-conf)
      (add-hook 'kill-emacs-hook (lambda ()
                                   (rclone-sync rclone-remote
                                                rclone-local
                                                rclone-path
                                                rclone-conf)))))
#+end_src

* Performance Optimization End
Close off the ~let~ statement at the beginning of the init file.

#+begin_src emacs-lisp :tangle yes
  (setq gc-cons-threshold 800000)
  )
#+end_src
