# -*-eval: (add-hook 'after-save-hook (lambda ()(org-babel-tangle)) nil t);-*-

#+title: Emacs Configuration
#+author: Thomas Freeman
#+date: Time-stamp: <2022-06-30 21:44:39 thomas>
#+description: This org-mode file contains an org-babel implementation of the .emacs or .emacs.d/init.el file.
#+language: en
#+property: header-args :results silent :exports code
#+options: tex:t

#+options: html-link-use-abs-url:nil html-postamble:auto
#+options: html-preamble:t html-scripts:nil html-style:t
#+options: html5-fancy:nil tex:t
#+html_doctype: xhtml-strict
#+html_container: div
#+html_content_class: content
#+keywords: Emacs
#+html_link_home: index.html
#+html_link_up: index.html
#+creator: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 27.1 (<a href="https://orgmode.org">Org</a> mode 9.5.2)

#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#-----------------------------------------------------------------------------------------

-----
Welcome to my Emacs configuration! This file contains the code along with documentation for customizing my Emacs with all the options that I prefer to use by default.

* About this Document

This file was written using Emacs Org Mode. This makes navigating and modifying my Emacs configuration much simpler as I can place different elements of my configuration under separate headings. The code in this file is placed in source code blocks that are tangled to the ~init.el~ file that Emacs will look for upon starting. When this file is saved, the source code blocks that are marked for tangling will write their contents to ~init.el~.

** Tags

Tags are used in this document to help make navigation of the packages easier and to provide additional information about piecing together this Emacs configuration. Below are descriptions of the tags and their meanings:

- deprecated :: This package has been "deprecated" in favor of another package that better integrates with this Emacs configuration or produces a better workflow.
- disabled :: Any package marked with this tag has been disabled due to it causing issues or the package was deprecated.
- email :: Any package related to email reading and composing is marked with this tag.
- go ::  Packged used for coding in the Go programming language (golang) are marked with this tag.
- guix :: Packages managed by GUIX are marked with this tag. There are a number of reasons why a package might be managed by GUIX over using package managers in Emacs:
    
  1. The package requires compilation on the host system (e.g. Pdf Tools and Org-roam). Using the GUIX package manager will manage the compilation automatically. Also, packages that need to be compiled are difficult to run on portable Emacs so they will be left out when Emacs is used as a portable app.
  2. The package is only run on a Linux System with GUIX installed or on the GUIX System Distribution so there is no need to have Emacs manage this package.
  3. The package relies on another program installed on the host system (e.g. Mu4e requires Mu).

- LaTeX :: Any extensions or additons to \LaTeX{} support in Emacs are marked with this tag.
- minibuffer :: This tag marks packages that change the behavior of the Emacs minibuffer.
- org :: Packages that are related to Org Mode are labeled with this tag.
- python :: Packages used to extend python coding are marked with this tag.
- testing :: A package or function that is added and is being tested for use is marked with this tag.
- Window  :: Customizations exclusively for the use on the Windows operating system are marked with this tag.

* Header for ~init.el~

The following code block will add a header to the ~init.el~ file when it is generated on saving:

#+begin_src emacs-lisp :tangle yes
  ;;; init.el --- Emacs initialization file -*- lexical-binding: t -*-

  ;; Copyright (C) 2022 Thomas Freeman

  ;; Author: Thomas Freeman
  ;; Maintainer: Thomas Freeman
  ;; Keywords: lisp
  ;; Version: 0.0.1
  ;; Created: 09 Jan 2022

  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation, either version 3 of the License, or
  ;; (at your option) any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

  ;;; Commentary:

  ;; This file is an init file for Emacs.
  ;;
  ;; This file is NOT a part of Emacs.
  ;;
  ;; This file IS NOT intended to be edited! It was generated by init.org.

  ;;; URL: https://github.com/tfree87/.emacs.d

  ;; For documentation and for editing this file, see the init.org in the
  ;; github repository tfree87/.emacs.d
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;;; Code:
#+end_src

* Performance Optimization Start

In order to slightly reduce the load time for Emacs, the whole ~init.el~ file can be wrapped in the following let statement to speed up the load process. This can help a little when Emacs is run as a portable app from a flash drive as I often do.See [[https://www.reddit.com/r/emacs/comments/3kqt6e/2_easy_little_known_steps_to_speed_up_emacs_start/][this Reddit post]] for more information.

#+begin_src emacs-lisp :tangle yes
  (let ((file-name-handler-alist nil))
#+end_src

* Load Path

#+begin_src emacs-lisp :tangle yes
  (let ((default-directory "~/.emacs.d/modules/"))
    (normal-top-level-add-subdirs-to-load-path))
#+end_src

* Running Emacs as a Portable App

I like to use Emacs at work and at home to boost my productivity, but I often find when I am at work or using another computer using Windows and I cannot always install Emacs to the host system. In this case, I run Emacs from a USB thumb drive so that I can still have access to the power of Emacs even when I am not working on my home personal computer. Running Emacs from a thumb drive has some caveats. For instance, if you are running Emacs from a thumb drive on a work computer and you do not have administrator access, then a lot of features will break. This section contains code that can be used to run Emacs.

** Check for Portable Emacs Instance

When runemacs.bat is executed, it will set the environment variable ~EMACS_PORTABLE~ to "Y". By checking for this, we can tell that Emacs that it was executed to be run from a flash drive.

#+name: portable_check
#+begin_src emacs-lisp
  (string= (getenv "EMACS_PORTABLE") "Y")
 #+end_src
 
** Set Location of Portable Git :git:

Straight.el cannot operate without access to Git. Luckily, there is a portable version of Git ([[https://github.com/sheabunge/GitPortable][sheabunge/GitPortable]]) for Windows that can be installed on the [[https://portableapps.com/][PortableApp]] platform to provide access to Git without having it installed on the host system. After downloading GitPortable, we need to tell Emacs where it can find the binary executable so that Emacs programs can call Git when needed.

The following line code will check to see if Emacs is being run as a portable app and, if it is, then add the path where git.exe can be found to the ~exec-path~ list:

 #+begin_src emacs-lisp :tangle yes :noweb yes
   (when <<portable_check>>
     (add-to-list 'exec-path "~/PortableApps/GitPortable/App/Git/bin"))
 #+end_src

* Custom Set Variables

In order to keep variables set by the customize interface or set during Emacs at runtime from being placed at the top of ~init.el~, I set the variables set from Emacs customize to be put into a separate file [[./custom.el]].

#+name: custom-file
#+begin_src emacs-lisp :tangle yes

  ;; Set the location of variables set using Emacs customize interface

  (setq custom-file "~/.emacs.d/custom.el")
#+end_src

Once the file location has been set, Emacs needs to load the custom file. This needs to be done early in the loading process because it contains the addresses for the package repositories. If this is not loaded before refreshing packages and making calls to ~use-package~, then the ~:ensure~ command will not be able to pull the packages and install them.

#+name: load-custom
#+begin_src emacs-lisp :tangle yes

  ;; Load the file custom.el file containing variables from Emacs customize

  (load custom-file)
#+end_src

* Package Management

In this section, I have included customization to replace the default Emacs package manager with [[https://github.com/raxod502/straight.el][straight.el]]. Some reasons for making this switch are:

1. It is easier to avoid conflicts with different package repositories such as duplicates packages in ELPA and MELPA.
2. I can define a specific fork to use for a specific package to get bug fixes or modifications.
3. The entire package repository is cloned, which, while it takes up a lot of space, allows for editing the source code directly if desired.
4. Github repositories that are not included in ELPA, MELPA, or marmalade can be pulled 
 used in ~use-package~ statements.
 
** Straight.el

Instead of using the built-in package manager, use [[https://github.com/raxod502/straight.el][straight.el]] to pull all the packages straight from their repositories.

#+begin_src emacs-lisp :tangle yes

  ;; Install Straight.el to manage packages

  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name
          "straight/repos/straight.el/bootstrap.el"
          user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
 #+end_src
 
** Install use-package

Use ~straight.el~ to install ~use-package~ to manage Emacs packages.

#+begin_src emacs-lisp :tangle yes
  ;; Set up use-package to manage package loading

  (straight-use-package 'use-package)
#+end_src

Straight can be configured as the default manager for ~use-package~ using the following option:

#+begin_src emacs-lisp :tangle no
  (setq straight-use-package-by-default t)
#+end_src

However, as I have started using the GUIX System Distribution I have found that it can be beneficial to pick and choose which packages are managed by straight and which are managed by GUIX . Packages that I want to use across Linux and Windows operating systems can be managed by straight, and those that I only use on GUIX or require compiling on the host system (such as EXWM and pdf-tools) can be managed by GUIX.

* Startup Tools

This section contains many of the tools used at Emacs startup that are helpful when other packages are initialized.

#+begin_src emacs-lisp :tangle yes
  ;; Startup Tools
#+end_src

** No-littering

The [[https://github.com/emacscollective/no-littering][no-littering]] package will put Emacs configuration files for many third-party packages into separate folders under ~.emacs.d/etc/~ to help keep the ~.emacs.d/~ from getting to cluttered with different configuration files. This needs to be run before the other packages are initialized in order to ensure that when the pacakges are loaded that their configuration files will be put into the correct location.

#+begin_src emacs-lisp :tangle yes
  (use-package no-littering
    :straight (no-littering :host github
                            :repo "emacscollective/no-littering"
                            :branch "master"))
#+end_src

** Whicher

[[https://github.com/abo-abo/whicher][Whicher]] provides a quick tool to check for missing executable dependencies without much cost to Emacs startup time. This needs to be loaded before the rest of init.el so that as init.el is loaded, it can look for missing executables on the host system.

#+begin_src emacs-lisp :tangle yes
  (use-package whicher
    :straight (whicher :host github
                       :repo "tfree87/whicher"
                       :branch "master")
    :custom
    (whicher-report-new-buffer t))
#+end_src

* Emacs Options

The code below collects customizations for Emacs built-in components.

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package emacs
    :custom
    <<emacs_custom>>
    :config
    <<emacs_config>>)
#+end_src

** General Configuration

This section contains modifications for Emacs that affect the behavior in nearly all buffers.

*** Automatic Time Stamps

Emacs supports time stamps in any text buffer where ~Time-stamp: <>~ can be found in the first eight lines. The ~time-stamp~ command can then be used to automatically update the time. A simpler solution, however, is to have Emacs automatically update the time stamp when the buffer is saved.

#+begin_src emacs-lisp :noweb-ref emacs_config
  (add-hook 'before-save-hook 'time-stamp)
#+end_src

***  Bidirectional Editing

Emacs supports bidirectional editing. This is rarely used feature for many and can actually result in slower performance. To improve performance if bidirectional editing it not used, the following can be set:

1. Tell Emacs that text should be read from left to right.

   #+begin_src emacs-lisp :noweb-ref emacs_custom
     (bidi-paragraph-direction 'left-to-right)
   #+end_src

2. Turn off bidrectional editing mode.
   
   #+begin_src emacs-lisp :noweb-ref emacs_config
     (if (version<= "27.1" emacs-version)
         (setq bidi-inhibit-bpa t))
    #+end_src
    
*** Desktop Save Mode :disabled:

The following option will cause Emacs to always save the state of Emacs when it was closed. Local buffers, tabs in ~tab-bar-mode~, and window arrangements are all saved if possible. Turning this on makes it much simpler to continue working on the same projects when Emacs is closed and then opened again.

#+begin_src emacs-lisp :noweb-ref emacs_custom
  ;;(desktop-save-mode t)
#+end_src

*** Display Battery Mode

Display Battery Mode will display the battery charge status in the modeline 

#+begin_src emacs-lisp :noweb-ref emacs_config
  (display-battery-mode t)
#+end_src

*** File Deletion and Backup

Changing how Emacs deletes files and how it creates backups.

**** Send Deleted Files to System Trash

 Emacs does not send files to the trash by default which is counter-intuitive for many beginning users. /In order to risk losing files it is a good idea to turn on the option to send all files to the system trash./

 #+begin_src emacs-lisp :noweb-ref emacs_custom
   (delete-by-moving-to-trash t)
 #+end_src
 
**** Backup Files with Version Control

 Emacs has a built-in version control system in which it will create a series of backup files. This will create a number of backup flies, however, that will need to be cleaned up on a regular basis.


 #+begin_src emacs-lisp :noweb-ref emacs_custom
   (version-control t)
   (delete-old-versions t)
   (vc-make-backup-files t)
 #+end_src
 
*** Inhibit Startup Screen

After seeing the startup screen hundreds of times, there is no longer any need to load it on startup as it no longer contains any new information.

#+begin_src emacs-lisp :noweb-ref emacs_custom
  (inhibit-startup-screen t)
#+end_src

*** Register Delay

#+begin_src emacs-lisp :noweb-ref emacs_custom
  (register-preview-delay 0)
#+end_src

*** Ring Bell Function

#+begin_src emacs-lisp :noweb-ref emacs_custom
  (ring-bell-function #'ignore)
  (visible-bell t)
#+end_src

*** Shorten "Yes or No" to "Y or N"

To make work faster, instead of typing "yes" or "no" for each question prompt, use just "y" or "n"
.

#+begin_src emacs-lisp :noweb-ref emacs_config
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

* Elfeed

Elfeed is a news and RSS reader for Emacs. The configuration for Elfeed can be found at [[file:modules/elfeed/freemacs-elfeed.org][elfeed module]].

#+begin_src emacs-lisp :tangle yes
  ;; Load Elfeed newsreader module

  (require 'freemacs-elfeed)
#+end_src

* Email

Email is managed using the Mu4e package that uses the Mu backend to search through emails that are stored using the Maildir format. The configuration can be found at [[file:modules/email/freemacs-email.org][email module]].

#+begin_src emacs-lisp :tangle yes
  ;; Load email module

  (require 'freemacs-email)
#+end_src

* Coding

Modifications to the coding modes for Emacs are defined in the [[file:modules/coding/freemacs-coding.org][coding module]].

#+begin_src emacs-lisp :tangle yes
  ;; Load the coding module

  (require 'freemacs-coding)
#+end_src

* Completion

While Emacs has built-in completion systems, the combination of the following tools makes Emacs completion very powerful:

+ Vertico
+ Orderless
+ Cape
+ Consult
+ Marginalia
+ Embark

The configuration of these elements can be found in the [[file:modules/completion/freemacs-completion.org][completion module]].

#+begin_src emacs-lisp :tangle yes
  ;; Load the completion module

  (require 'freemacs-completion)
#+end_src

* File Management

#+begin_src emacs-lisp :tangle yes
  ;; Load file tools module

  (require 'freemacs-dired)
#+end_src

[[https://github.com/sunrise-commander/sunrise-commander][Sunrise Commander]] is a two-pane orthodox file manager similar to Midnight Commander.

#+begin_src emacs-lisp :tangle yes
  ;; Load sunrise module

  (require 'freemacs-sunrise)
#+end_src

* Navigation and Session

This section contains customizations for controlling how to navigate between Emacs windows, frames, and buffers.

#+begin_src emacs-lisp :tangle yes
  ;; Navigation and Session Configuration
#+end_src

** Bufler

[[https://github.com/alphapapa/bufler.el][Bufler]] provides a buffer switching menu that has some enhanced automatic groupings that make it easier to configure than [[https://www.emacswiki.org/emacs/IbufferMode][Ibuffer]] as it requires less manual work to create buffer groups. It can also sort buffers into groups based on projects using ~project.el~.

#+begin_src emacs-lisp :tangle yes
  (use-package bufler
    :straight t
    :bind ("C-x C-b" . bufler))
#+end_src

** Burly

[[https://github.com/alphapapa/burly.el][Burly]] is a tool to save buffer, window, and frame configurations among sessions. Although Emacs has Tab Bar Mode and Desktop Mode, Burly has a couple benefits that make it worth adopting for some:

1. Saving the Emacs Desktop automatically opens it on the next session which can slow down Emacs load time especially if you only wish to start a new session without opening any of the old buffers.
2. Burly allows you save the different sessions with names so you can call up different sessions as you choose.
3. Loading of Burly can be deferred until you call the Burly commands.

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package burly
    :straight (burly :host github
                     :repo "tfree87/burly.el"
                     :branch "master")
    :commands (burly-bookmark-frames
               burly-bookmark-windows
               burly-open-bookmark))
#+end_src

** Recentf Mode

Recentf Mode will save a list of recent files so they can be called easily after restarting Emacs. To access the files, ~M-x recentf-open-files~ can be called to get a list of the recent files in a buffer.

#+begin_src emacs-lisp :noweb-ref emacs_config
  (recentf-mode 1)
#+end_src

** Winner Mode

[[https://www.emacswiki.org/emacs/WinnerMode][Winner Mode]] makes it easy to return to old window configurations in Emacs by simply using the keyboard command ~C-<left>~.

#+begin_src emacs-lisp :noweb-ref emacs_config
  (winner-mode t)
#+end_src

** Winum

Winum is a package that adds number to the modeline for each window in Emacs. Windows can then easily be switched from one to the next by using the key combination ~C-x w~ followed by the number of the correct window.

This package is similar to [[https://github.com/abo-abo/ace-window][ace-window]] but it has a few advantages:

1. This package has a key binding that does not conflict with ~M-o~ in [[Sunrise Commander]]
2. This package works well with [[https://github.com/ch11ng/exwm][EXWM]]. Ace Window numbers do not display in [[https://github.com/ch11ng/exwm][EXWM]] windows that are running X11 applications.
3. ~C-x w~ is similar to the window creation and deletion commands ~C-x~ which may make it easier to remember the key binding.

#+begin_src emacs-lisp :tangle yes
  (use-package winum
    :straight t
    :defer 3
    :config
    (winum-mode t))
#+end_src

* Org

#+begin_src emacs-lisp :tangle yes
  ;; Load the Org Mode module

  (require 'freemacs-org)
#+end_src

* Writing/Publishing/Reading

This section contains customizations for Emacs to improve the environment for writing papers, publishing paper and websites, and reading documents.

#+begin_src emacs-lisp :tangle yes
  ;; Writing/Publishing/Reading Configuation
#+end_src

** Academic Phrases

[[https://github.com/nashamri/academic-phrases][Academic phrases]] is a package that provides a number of easy-to-use templates for writing academic text if you happen to have writer's block. Calling the function ~M-x academic-phrases~ provides a searchable list of these templates for your use.

#+begin_src emacs-lisp :tangle yes
  (use-package academic-phrases
    :straight t
    :defer t)
#+end_src

** AUCTeX :LaTeX:

[[https://www.gnu.org/software/auctex/][AUCTeX]] for writing documents using \LaTeX{}.

#+begin_src emacs-lisp :tangle yes :noweb yes
    (use-package auctex
      :straight t
      :defer t
      :custom
      (TeX-auto-save t)
      (TeX-parse-self t)
      (TeX-master nil)
      <<auctex_custom>>)
#+end_src

*** Use BibLaTeX

BibLaTeX has more powerful features than standard BibTeX.

#+begin_src emacs-lisp :noweb-ref auctex_custom
(bibtex-dialect 'biblatex)
#+end_src

** Citations :org:

This section contains customizations for adding citations into documents in Emacs.

*** Citar

[[https://github.com/emacs-citar/citar][Citar]] is a citation tool that integrates well with [[Vertico]], [[Embark]], and [[Marginalia]].

#+begin_src emacs-lisp :tangle yes
  (use-package citar
    :straight (citar :host github
                     :repo "emacs-citar/citar"
                     :branch "main")
    :after org
    :custom
    (citar-bibliography org-cite-global-bibliography))
#+end_src

*** Org Citation Options :org:

The following lines will tell Org Mode to use Citar as the processor for ~org-cite~ and will tell Org Mode where to find the default bibliography file.

#+begin_src emacs-lisp :noweb-ref org_customize
  (org-cite-global-bibliography '("~/bib/bib.bib"))
  (org-cite-insert-processor 'citar)
  (org-cite-follow-processor 'citar)
  (org-cite-activate-processor 'citar)
#+end_src

** Flyspell

Flyspell mode can be hooked to various buffer modes so that spell-checking can be done as typing occurs. As you type, a red wavy line will appear under text that it deems to be incorrectly spelled.

In order for this to work in Windows, hunspell must be installed with the proper dictionaries. I have downloaded hunspell from ezwinports and included it in my ~~/.emacs.d/~ directory so that I can also use hunspell when I am using Emacs as a portable app from a USB drive. To use hunspell for spell checking, we must first configure the ispell package:

#+begin_src emacs-lisp :tangle yes
  (use-package ispell
    :straight (:type built-in)
    :defer t
    :config
    (if (eq system-type 'windows-nt)
      (progn (setq ispell-program-name (expand-file-name "~/.emacs.d/hunspell/bin/hunspell.exe"))
             (setq ispell-personal-dictionary "~/.emacs.d/hunspell_en_US")
             (setq ispell-local-dictionary "en_US")
             (setq ispell-local-dictionary-alist
                   '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8))))
        (setq ispell-program-name (whicher "hunspell"))))
#+end_src

Once hunspell is set up as the default spell checker, we can then hook flyspell into our editing modes.

#+begin_src emacs-lisp :tangle yes
  (use-package flyspell
    :straight (:type built-in)
    :defer t
    :init
    (add-hook 'prog-mode-hook 'flyspell-prog-mode)
    (add-hook 'text-mode-hook 'flyspell-mode))
#+end_src

** Markdown Mode

[[https://jblevins.org/projects/markdown-mode/][Markdown Mode]] for markdown files. While I prefer Org-mode for rich-text editing in Emacs, Github primarily supports markdown so I want to be able to edit and view these files when needed.

#+begin_src emacs-lisp :tangle yes :noweb no-export
  (use-package markdown-mode
    :straight t
    :mode ("\\.\\(m\\(ark\\)?down\\|md\\)$" . markdown-mode)
    :init
    (whicher "pandoc")
    <<markdown_init>>
    :config
    (bind-key "A-b" (surround-text-with "+*") markdown-mode-map)
    (bind-key "s-b" (surround-text-with "**") markdown-mode-map)
    (bind-key "A-i" (surround-text-with "*") markdown-mode-map)
    (bind-key "s-i" (surround-text-with "*") markdown-mode-map)
    (bind-key "A-=" (surround-text-with "`") markdown-mode-map)
    (bind-key "s-=" (surround-text-with "`") markdown-mode-map))
#+end_src

*** Set Markdown Mode to use Pandoc

Since [[https://pandoc.org/][Pandoc]] can be installed on both Linux and in Windows with Chocolatey, set Markdown Mode to use this as the default markdown command.

#+begin_src emacs-lisp :noweb-ref markdown_init
  (setq markdown-command '("pandoc" "--from=markdown" "--to=html5"))
#+end_src

** PDF Tools :guix:

[[https://github.com/politza/pdf-tools][PDF Tools]] is a faster and more feature-rich than the built in DocView. Currently, I install this package using the GUIX package manager.

#+begin_src emacs-lisp :tangle yes
  (use-package pdf-tools
    :magic ("%PDF" . pdf-view-mode)
    :config
    (pdf-loader-install :no-query))
#+end_src

*** Single Space at the End of Sentences

Emacs when navigating expects sentences to end with a double space after a period. While this makes documents written in plain text to look more attractive and more readable, this convention is not used much anymore and this will break emacs commands for killing and navigating sentences.

#+begin_src emacs-lisp :noweb-ref emacs_custom
  (sentence-end-double-space nil)
#+end_src

* Shells and Terminals

This section contains configuration options for terminals in Emacs. 

#+begin_src emacs-lisp :tangle yes
  ;; Shells and Terminals Configuration
#+end_src

** Eshell

Eshell is a very powerful lisp-based shell that I have learned to love most because you can redirect output directly to Emacs buffers. This feature has made it my default shell and I have switched to it from using mostly Z shell because I send stuff to and from Emacs buffers. This feature really is a game changer.

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package eshell
    :straight (:type built-in)
    :defer t
    :hook
    <<eshell_prompt>>
    (eshell-mode . (lambda ()
                     <<eshell_visual_commands>>
                     <<eshell_aliases>>))
    :custom
    (eshell-error-if-no-glob t)
    (eshell-hist-ignoredups t)
    (eshell-save-history-on-exit t)
    (eshell-destroy-buffer-when-process-dies t)
    :config
    (setenv "PAGER" "cat"))
  #+end_src
  
*** Eshell Aliases

Below are a list of command-line aliases for use in eshell.

#+name: eshell_aliases
#+begin_src emacs-lisp :noweb-ref eshell_aliases
  (eshell/alias "ff" "find-file $1")
  (eshell/alias "emacs" "find-file $1")
  (eshell/alias "untar" "tar -zxvf")
  (eshell/alias "cpv" "rsync -ah --info=progress2")
  (eshell/alias "ll" "ls -Alh")
#+end_src

*** Eshell Visual Commands

Many commands when run in eshell turn into a mess as it is not an ansi-term. Any interactive commands that need the full ansi-term to display properly are listed below so that when they are run from the eshell they will open in ansi-tem and display properly.

#+name: eshell_visual_commands
#+begin_src emacs-lisp :noweb-ref eshell_visual_commands
  (add-to-list 'eshell-visual-commands "htop")
  (add-to-list 'eshell-visual-commands "ipython")
  (add-to-list 'eshell-visual-commands "rclone")
  (add-to-list 'eshell-visual-commands "ssh")
  (add-to-list 'eshell-visual-commands "tail")
  (add-to-list 'eshell-visual-commands "top")
#+end_src

*** Esh Autosuggest

#+begin_src emacs-lisp :tangle yes
  (use-package esh-autosuggest
    :straight t
    :hook (eshell-mode . esh-autosuggest-mode))
#+end_src

*** Eshell Git Prompt

[[https://github.com/xuchunyang/eshell-git-prompt][Eshell Git Prompt]] provides a series of Eshell prompts that provide extra information including the git status of the current project.

#+begin_src emacs-lisp :tangle yes
  (use-package eshell-git-prompt
    :straight (emacs-git-prompt :host github
                                :repo "tfree87/eshell-git-prompt"
                                :branch "master")
    :defer t)
#+end_src

**** Set the Eshell prompt on load

This method was the only method I have found that loaded the ~eshell-git-prompt~ immediately when Eshell was loaded.

#+begin_src emacs-lisp :noweb-ref eshell_prompt
  (eshell-load . (lambda ()
                        (eshell-git-prompt-use-theme 'multiline2)))
#+end_src

*** Eshell Toggle

[[https://github.com/4DA/eshell-toggle][Eshell Toggle]] makes it easy to pull up a temporary Eshell buffer for running commands quickly from the working directory of that buffer.

#+begin_src emacs-lisp :tangle yes
  (use-package eshell-toggle
    :straight (eshell-toggle :repo "4DA/eshell-toggle"
                             :host github
                             :repo "master")
    :custom
    (eshell-toggle-size-fraction 3)
    (eshell-toggle-run-command nil)
    (eshell-toggle-init-function #'eshell-toggle-init-eshell)
    :bind
    ("M-s-`" . eshell-toggle))
#+end_src

*** Oh My Esh

Oh My Esh is my pacakge that aims to reproduce some of the plugin functionality that can be found in the plugins from Oh My Zsh for the Z shell.

#+begin_src emacs-lisp :tangle yes
  (use-package oh-my-eshell
    :straight (oh-my-eshell :repo "tfree87/OhMyEshell"
                            :branch "main"
                            :host github)
    :after eshell)
#+end_src

** PowerShell :Windows:

[[https://github.com/jschaf/powershell.el][Powershell.el]] creates a function that will launch an inferior shell that will run the Windows PowerShell tool.

#+begin_src emacs-lisp :tangle yes
  (use-package powershell
    :straight t
    :if (eq system-type 'windows-nt)
    :defer t
    :init
    (whicher "powershell.exe")
    :config
    ;; Change default compile command for powershell
    (add-hook 'powershell-mode-hook
              (lambda ()
                (set (make-local-variable 'compile-command)
                     (format
                       "powershell.exe -NoLogo -NonInteractive -Command \"& '%s'\"")
                      (buffer-file-name)))))
#+end_src

** Vterm :guix:

Vterm is a terminal emulator in Emacs that is written in C and compiled on the host system. This makes it faster than than ~term~ or ~ansi-term~ in Emacs. It also replicates a traditional terminal more closely than the other options in Emacs.

#+begin_src emacs-lisp :tangle yes
  (use-package vterm
    :defer t)
#+end_src

* Theme

Changes to Emacs appearance and theme can be found in the [[file:modules/theme/freemacs-theme.org][theme module]].

#+begin_src emacs-lisp :tangle yes
  ;; Load theme module

  (require 'freemacs-theme)
#+end_src

#+begin_src emacs-lisp :tangle yes
  (require 'freemacs-alltheicons)
#+end_src

* EXWM

EXWM is a window manager that runs entirely wihtin Emacs. With EXWM, Emacs frames and windows can be used to manage X11 applications. Each X11 application runs in a separate window and can be accessed as a separate buffer using Emacs commands.

#+begin_src emacs-lisp :tangle yes
  ;; Load the EXWM module

  (require 'freemacs-exwm)
#+end_src

* Other

This section contains configuration for packages that do no fit into the other categories.

** Docker

[[https://github.com/Silex/docker.el][Docker Mode]] is an interface in Emacs to manage Docker containers.

#+begin_src emacs-lisp :tangle yes
  (use-package docker
    :straight t
    :init
    (whicher "docker")
    :bind ("C-c d" . docker))
#+end_src

** Docker Compose

[[https://github.com/meqif/docker-compose-mode][Docker Compose Mode]] is a major mode for editing Docker Compose files.

#+begin_src emacs-lisp :tangle yes
  (use-package docker-compose-mode
    :straight t
    :defer t
    :init
    (whicher "docker-compose"))
#+end_src

** EMMS :disabled:

/This package has been disabled as it provides little use for me./

EMMS is a multimedia player for Emacs. It is an interface that is used to control other players that operate in the background.

#+begin_src emacs-lisp :tangle yes
  (use-package emms
    :straight t
    :defer t
    :custom
    (emms-source-file-default-directory "~/Music/")
    :config
    (require 'emms-setup)
    (emms-all)
    (emms-default-players)
    (global-set-key (kbd "<XF86AudioPrev>") 'emms-previous)
    (global-set-key (kbd "<XF86AudioNext>") 'emms-next)
    (global-set-key (kbd "<XF86AudioPlay>") 'emms-pause))
#+end_src

** Gnuplot

[[https://github.com/emacs-gnuplot/gnuplot][Gnuplot]] mode can be used for editing files that are used to define a plot style and layout and allow for execution of the code in an Emacs buffer.

#+begin_src emacs-lisp :tangle yes
  (use-package gnuplot
    :straight t
    :init
    (whicher "gnuplot")
    :defer t)
#+end_src

** Helpful

[[https://github.com/Wilfred/helpful][Helpful]] improves the Emacs help functions by adding new features to the ~*Help*~ buffers such as:

- Links to source code
- Better formatting of docstrings
- Lists of callers
- Keymaps
- Aliases
- And more...

#+begin_src emacs-lisp :tangle yes
  (use-package helpful
    :straight t
    :defer t
    :bind
    ("C-h f" . #'helpful-callable)
    ("C-h v" . #'helpful-variable)
    ("C-h k" . #'helpful-key)
    ("C-c C-d" . #'helpful-at-point)
    ("C-h F" . #'helpful-function)
    ("C-h C" . #'helpful-command))
#+end_src

** Ledger

To conduct plain-text accounting in Emacs, [[https://github.com/ledger/ledger-mode][ledger-mode]] needs to be installed from the package repositories. This mode will create faces for the text and highlight transactions while also providing the functionality to execute ledger reports in an Emacs buffer. No shell needed.

#+begin_src emacs-lisp :tangle yes
    (use-package ledger-mode
      :straight t
      :defer t
      :init
      (whicher "ledger"))
#+end_src

** Multiple Cursors

[[https://github.com/magnars/multiple-cursors.el][multiple-cursors.el]] allows for editing Emacs buffers at multiple locations simultaneously at the same time and has transformed how I use Emacs Dired. I can use it to edit many file names at once in a directory by making any dired buffer editable by pressing =C-x C-q=.

#+begin_src emacs-lisp :tangle yes
  (use-package multiple-cursors
    :straight t
    :defer t
    :bind
    ("C-S-c C-S-c" . 'mc/edit-lines)
    ("C->" . 'mc/mark-next-like-this)
    ("C-<" . 'mc/mark-previous-like-this)
    ("C-c C-<" . 'mc/mark-all-like-this))
#+end_src

** PlantUML

[[https://plantuml.com/][PlantUML]] is a language that can interpret code to create flowcharts and UML diagrams. The syntax is similar to programming languages thereby making it fast and easy to create accurate, auto-generated charts that don't require a lot of dragging boxes around as you might with a graphical tool such as LibreOffice Draw.

*** Install PlantUML Mode

[[https://github.com/skuro/plantuml-mode][PlantUML mode]] is not installed by default, so we need ~use-package~ to download and install it.

#+begin_src emacs-lisp :tangle yes
  (use-package plantuml-mode
    :straight t
    :defer t
    :after org)
#+end_src

*** Set Location of PlantUML Binary

When Emacs is run as a portable app on a USB drive, Emacs needs to know the location of the PlantUML executable which I place in the .emacs.d directory.

#+begin_src emacs-lisp :noweb-ref org_customize
  (org-plantuml-jar-path (expand-file-name "~/.emacs.d/plantuml/plantuml.jar"))
#+end_src

** Popper

[[https://github.com/karthink/popper][Popper]] lets a user define any window as a short-term pop up window.

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package popper
    :straight t
    :bind (("C-`"   . popper-toggle-latest)
           ("M-`"   . popper-cycle)
           ("C-M-`" . popper-toggle-type))
    :init
    <<popper_init>>
    (popper-mode +1)
    (popper-echo-mode +1))
#+end_src

*** Popper Buffer Buffers

For each buffer that will become a popper pop up buffer, it must be defined below:

#+begin_src emacs-lisp :noweb-ref popper_init
  (setq popper-reference-buffers
          '("\\*Messages\\*"
            "\\*Embark Actions\\*"
            "Output\\*$"
            "\\*Async Shell Command\\*"
            "\\*Whicher Report\\*"
            help-mode
            compilation-mode))
#+end_src

** Savehist

Savehist will save the selections from completion history between Emacs sessions. This makes it so that commonly used commands and files will float to the top of the minibuffer in [[Vertico]].

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package savehist
    :straight (:type built-in)
    :init
    (savehist-mode))
  #+end_src
  
** Which-key
[[https://github.com/justbur/emacs-which-key][Which-key]] provides a pop-up menu when there is a pause in the minibuffer or if executed directly to show the keyboard commands available to the current buffer.

#+begin_src emacs-lisp :tangle yes :noweb yes
  (use-package which-key
    :straight t
    :defer 3
    :custom
    <<wk_custom>>
    :config
    <<wk_config>>
    (which-key-mode))
#+end_src

*** Activating Which-key

How to start which-key

**** C-h During Key Combination Entry

Type C-h during any key combination to pop-up which key

#+begin_src emacs-lisp :noweb-ref wk_custom
  (which-key-show-early-on-C-h t)
#+end_src

**** Press <f4> in Any Mode

Use the <f4> key in any major mode to see the key bindings

#+begin_src emacs-lisp :noweb-ref wk_config
  (global-set-key (kbd "<f4>") 'which-key-show-major-mode)
#+end_src

*** Which-key Window Location

Set up which-key to use the side window preferably

#+begin_src emacs-lisp :noweb-ref wk_config
  (which-key-setup-side-window-right-bottom)
#+end_src

** YASnippet

YASnippet is a system that povides easy access to many templates that can be inserted into buffers based on their major mode.

*** Install YASnippet

[[https://github.com/joaotavora/yasnippet][YASnippet]] takes a small bit of text or an abbreviation and expands it into a template once the ~<TAB>~ key has been pressed. This is very useful for typing sections of text that are repeated often such as creating the =#+begin_src emacs-lisp :tangle yes= blocks in this Org-mode file such as the one below.

#+begin_src emacs-lisp :tangle yes
  (use-package yasnippet
    :straight t
    :defer 3
    :config
    (yas-global-mode 1))
#+end_src

*** Install Snippets

The package [[https://github.com/AndreaCrotti/yasnippet-snippets][YASnippet Snippets]] loads many pre-defined templates for YASnippet. This is very useful as many of the best use cases for YASnippet are already included in this package making reducing the need to create individual custom templates.

#+begin_src emacs-lisp :tangle yes
  (use-package yasnippet-snippets
    :straight t
    :defer t)
#+end_src

* Emacs Server

Running Emacs as a server means that if I create a new instance of Emacs with the command ~emacs~, I can then use the command ~emacsclient -c -n~ in order to quickly open a new Emacs buffer that is part of the same Emacs session.

I have this option run only when I am not executing Emacs as a portable app as it is unlikely that there will be Emacs installed on the system that I am running Emacs on when I am using it portably.

#+begin_src emacs-lisp :tangle yes :noweb yes
  ;; Start an Emacs server

  (use-package server
    :straight (:type built-in)
    :config
    (when (not <<portable_check>>)
      (when (not (server-running-p))
        (server-start))))
#+end_src

* Custom Functions

This section contains custom functions that I have either created myself or borrowed from others to accomplish small tasks.

#+begin_src emacs-lisp :tangle yes
;; Custom Function Definitions
#+end_src

** Sudo Find File

This function creates a ~sudo-find-file~ command that can be used to open files as the super user. This can be really useful when combined with Embark. This function was copied from https://karthinks.com/software/fifteen-ways-to-use-embark/.

#+begin_src emacs-lisp :tangle yes
  (whicher "sudo")
  (defun sudo-find-file (file)
      "Open FILE as root."
      (interactive "FOpen file as root: ")
      (when (file-writable-p file)
        (user-error "File is user writeable, aborting sudo"))
      (find-file (if (file-remote-p file)
                     (concat "/" (file-remote-p file 'method) ":"
                             (file-remote-p file 'user) "@" (file-remote-p file 'host)
                             "|sudo:root@"
                             (file-remote-p file 'host) ":" (file-remote-p file 'localname))
                   (concat "/sudo:root@localhost:" file))))
#+end_src

* Update Org Files on Portable App Startup

When running Emacs as a portable app, I want to pull down the latest versions of my ~org-agenda-files~ and other Org Mode files onto my USB flash drive (which has been set as the home directory). I also want to make sure to update the remote location when Emacs is killed so that all of my changes will be synced with the cloud and available for use on other systems.

#+begin_src emacs-lisp :tangle yes :noweb yes
  ;; Sync Dropbox containing org agenda files on load and close

  (when <<portable_check>>
    (setq rclone-path "~/rclone/rclone.conf")
    (rclone-run-remote-to-local "sync" "~/Dropbox" "dropbox:")
    (add-hook 'kill-emacs-hook (rclone-run-local-to-remote "sync"
                                                           "~/Dropbox"
                                                           "dropbox:")))
#+end_src

* Performance Optimization End

Close off the ~let~ statement at the beginning of the init file.

#+begin_src emacs-lisp :tangle yes
  (setq gc-cons-threshold 800000)
  )
#+end_src

* End

Add a final comment to indicate the end of the file.

#+begin_src emacs-lisp :tangle yes
  (provide 'init)

  ;;; init.el ends here
#+end_src

